<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Ë§áÁ¥†Èñ¢Êï∞„Ç®„ÇØ„Çπ„Éó„É≠„Éº„É©„Éº</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overscroll-behavior: none;
        }

```
    html {
        overflow: hidden;
        touch-action: none;
        overscroll-behavior: none;
        height: 100vh;
        height: 100dvh; /* Dynamic viewport height */
    }
    
    body {
        overflow: hidden;
        font-family: 'Arial', sans-serif;
        touch-action: none;
        overscroll-behavior: none;
        height: 100vh;
        height: 100dvh;
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    
    #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
    }
    
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 100;
        max-width: 300px;
    }
    
    .button-group {
        margin: 10px 0;
    }
    
    button {
        background: rgba(100, 100, 255, 0.8);
        border: none;
        color: white;
        padding: 8px 12px;
        margin: 3px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        transition: background 0.2s;
    }
    
    button:hover {
        background: rgba(120, 120, 255, 1);
    }
    
    button.active {
        background: rgba(255, 100, 100, 0.9);
    }
    
    input[type="range"] {
        width: 100%;
        margin: 5px 0;
    }
    
    /* Virtual Joysticks */
    .joystick {
        position: absolute;
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        bottom: 30px;
        display: none;
        touch-action: none;
        z-index: 1000;
        transition: left 0.1s ease-out, bottom 0.1s ease-out;
    }
    
    .joystick.active {
        display: block;
    }
    
    #leftJoystick {
        left: 30px;
    }
    
    .joystick-handle {
        position: absolute;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        touch-action: none;
    }
    
    #info {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 12px;
        text-align: center;
    }
    
    #coordSystem {
        position: absolute;
        top: 10px;
        right: 10px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-size: 11px;
        line-height: 1.6;
    }
    
    #coordSystem div {
        margin: 3px 0;
    }
    
    @media (max-width: 768px) {
        #ui {
            font-size: 11px;
            padding: 10px;
            max-width: 200px;
        }
        
        button {
            padding: 6px 8px;
            font-size: 10px;
        }
    }
</style>
```

</head>
<body>
    <canvas id="canvas"></canvas>

```
<div id="ui">
    <div><strong>Ë§áÁ¥†Èñ¢Êï∞„Ç®„ÇØ„Çπ„Éó„É≠„Éº„É©„Éº</strong></div>
    <div class="button-group">
        <div>Èñ¢Êï∞:</div>
        <button id="funcZ2" class="active">z¬≤</button>
        <button id="funcZ3">z¬≥</button>
        <button id="funcExp">e^z</button>
        <button id="funcSin">sin(z)</button>
        <button id="funcCos">cos(z)</button>
    </div>
    <div class="button-group">
        <div>Âõ∫ÂÆöËª∏:</div>
        <button id="axisImX" class="active">Im(x)Âõ∫ÂÆö</button>
        <button id="axisImY">Im(y)Âõ∫ÂÆö</button>
    </div>
    <div class="button-group">
        <label id="sliderLabel">Im(z) Âõ∫ÂÆöÂÄ§: 0.00</label>
        <input type="range" id="fixedValueSlider" min="-5" max="5" step="0.1" value="0">
    </div>
    <div class="button-group">
        <button id="toggleFormulas">Êï∞ÂºèË°®Á§∫: OFF</button>
    </div>
    <div style="margin-top: 10px; font-size: 11px; opacity: 0.8;">
        <div>PC: WASDÁßªÂãï, „Éû„Ç¶„ÇπË¶ñÁÇπ</div>
        <div>Space‰∏äÊòá, Ctrl‰∏ãÈôç, ShiftËµ∞„Çã</div>
    </div>
    <div class="button-group">
        <button id="fullscreenBtn" style="width: 100%; background: rgba(50, 200, 50, 0.8); margin-top: 8px;">üì± ÂÖ®ÁîªÈù¢Ë°®Á§∫</button>
    </div>
</div>

<div id="leftJoystick" class="joystick">
    <div class="joystick-handle"></div>
</div>

<div id="info">
    ‰ΩçÁΩÆ: (0.00, 0.00, 0.00) | f(z) = 0.00 + 0.00i
</div>

<div id="coordSystem">
    <div><strong>Â∫ßÊ®ôÁ≥ª (Âè≥ÊâãÁ≥ª)</strong></div>
    <div style="color: #ff8888;">ü°¢ XËª∏: Re(z) - ÂÆüÈÉ®</div>
    <div style="color: #88ff88;">ü°° YËª∏: Re(f) or Im(f)</div>
    <div style="color: #8888ff;">ü°£ ZËª∏: Im(z) - ËôöÈÉ®</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Game state
    const state = {
        mode: 'real', // 'real', 'imag', 'abs'
        func: 'z2', // 'z2', 'z3', 'exp', 'sin', 'cos'
        fixedAxis: true,
        fixedAxisType: 'y', // 'x' or 'y' - which imaginary axis to fix
        fixedValue: 0,
        isMobile: false,
        showFormulas: false
    };
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    scene.fog = new THREE.Fog(0x1a1a2e, 30, 150);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 5, 10);
    
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // Add grid and axes
    function createAxesAndGrid() {
        const gridSize = 200;
        const gridDivisions = 400;
        
        // Grid on XZ plane (ground)
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // Main axes
        const axesHelper = new THREE.AxesHelper(25);
        scene.add(axesHelper);
        
        // Create thicker colored axes
        const axesMaterial = {
            x: new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }),
            y: new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 }),
            z: new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2 })
        };
        
        // X axis (red) - Re(z)
        const xGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-100, 0, 0),
            new THREE.Vector3(100, 0, 0)
        ]);
        const xAxis = new THREE.Line(xGeometry, axesMaterial.x);
        scene.add(xAxis);
        
        // Y axis (green) - Re(f) or Im(f)
        const yGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -100, 0),
            new THREE.Vector3(0, 100, 0)
        ]);
        const yAxis = new THREE.Line(yGeometry, axesMaterial.y);
        scene.add(yAxis);
        
        // Z axis (blue) - Im(z)
        const zGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, -100),
            new THREE.Vector3(0, 0, 100)
        ]);
        const zAxis = new THREE.Line(zGeometry, axesMaterial.z);
        scene.add(zAxis);
        
        // Add tick marks every 1 unit
        const tickSize = 0.2;
        const tickMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
        
        for (let i = -100; i <= 100; i += 1) {
            if (Math.abs(i) < 0.01) continue; // Skip origin
            
            // X axis ticks
            const xTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(i, -tickSize, 0),
                new THREE.Vector3(i, tickSize, 0)
            ]);
            scene.add(new THREE.Line(xTickGeom, tickMaterial));
            
            // Y axis ticks
            const yTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-tickSize, i, 0),
                new THREE.Vector3(tickSize, i, 0)
            ]);
            scene.add(new THREE.Line(yTickGeom, tickMaterial));
            
            // Z axis ticks
            const zTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -tickSize, i),
                new THREE.Vector3(0, tickSize, i)
            ]);
            scene.add(new THREE.Line(zTickGeom, tickMaterial));
        }
        
        // Add spheres and text labels at every 5 units
        const sphereGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        // Create canvas for text labels
        function createTextSprite(text, color = '#ffffff') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            
            context.fillStyle = color;
            context.font = 'Bold 40px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 64, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 1, 1);
            
            return sprite;
        }
        
        for (let i = -100; i <= 100; i += 5) {
            if (i === 0) continue;
            
            // X axis markers
            const xSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            xSphere.position.set(i, 0, 0);
            scene.add(xSphere);
            
            const xLabel = createTextSprite(i.toString(), '#ff8888');
            xLabel.position.set(i, -1.5, 0);
            scene.add(xLabel);
            
            // Y axis markers
            const ySphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            ySphere.position.set(0, i, 0);
            scene.add(ySphere);
            
            const yLabel = createTextSprite(i.toString(), '#88ff88');
            yLabel.position.set(-1.5, i, 0);
            scene.add(yLabel);
            
            // Z axis markers
            const zSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            zSphere.position.set(0, 0, i);
            scene.add(zSphere);
            
            const zLabel = createTextSprite(i.toString(), '#8888ff');
            zLabel.position.set(0, -1.5, i);
            scene.add(zLabel);
        }
    }
    
    createAxesAndGrid();
    
    // Complex function computation
    function complexFunc(x, y, funcType) {
        const z = { re: x, im: y };
        let result = { re: 0, im: 0 };
        
        switch(funcType) {
            case 'z2':
                // z^2 = (x+iy)^2 = x^2 - y^2 + 2xyi
                result.re = z.re * z.re - z.im * z.im;
                result.im = 2 * z.re * z.im;
                break;
            case 'z3':
                // z^3 = z^2 * z
                const z2_re = z.re * z.re - z.im * z.im;
                const z2_im = 2 * z.re * z.im;
                result.re = z2_re * z.re - z2_im * z.im;
                result.im = z2_re * z.im + z2_im * z.re;
                break;
            case 'exp':
                // e^z = e^(x+iy) = e^x * (cos(y) + i*sin(y))
                const expRe = Math.exp(z.re);
                result.re = expRe * Math.cos(z.im);
                result.im = expRe * Math.sin(z.im);
                break;
            case 'sin':
                // sin(z) = sin(x+iy) = sin(x)cosh(y) + i*cos(x)sinh(y)
                result.re = Math.sin(z.re) * Math.cosh(z.im);
                result.im = Math.cos(z.re) * Math.sinh(z.im);
                break;
            case 'cos':
                // cos(z) = cos(x+iy) = cos(x)cosh(y) - i*sin(x)sinh(y)
                result.re = Math.cos(z.re) * Math.cosh(z.im);
                result.im = -Math.sin(z.re) * Math.sinh(z.im);
                break;
        }
        
        return result;
    }
    
    function getHeight(x, z) {
        // x = Re(z), z = Im(z) in 3D space
        const result = complexFunc(x, z, state.func);
        
        switch(state.mode) {
            case 'real':
                return result.re;
            case 'imag':
                return result.im;
            case 'abs':
                return Math.sqrt(result.re * result.re + result.im * result.im);
        }
    }
    
    // Create surface
    let surface;
    let formulaLabels = []; // Store formula labels for toggling
    
    function createSurface() {
        if (surface) {
            scene.remove(surface);
            surface.geometry.dispose();
            surface.material.dispose();
        }
        
        // Remove old formula labels
        formulaLabels.forEach(label => scene.remove(label));
        formulaLabels = [];
        
        // Fixed mode: Im(z) = fixedValue, draw (Re(z), Re(f), Im(f)) curve
        const resolution = state.isMobile ? 800 : 1200;
        const range = 40;
        
        const points = [];
        const colors = [];
        
        // Helper function to create formula text sprite
        function createFormulaSprite(x, y, text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = '#ffffff';
            context.font = 'Bold 24px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 128, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 1, 1);
            sprite.visible = state.showFormulas;
            
            return sprite;
        }
        
        for (let i = 0; i <= resolution; i++) {
            const t = (i / resolution) * 2 - 1;
            const realPart = t * range; // Real part from -range to +range
            
            let x, y; // x and y for the complex number z = x + iy
            
            if (state.fixedAxisType === 'y') {
                // Im(y) fixed: z = x + i*fixedValue
                x = realPart;
                y = state.fixedValue;
            } else {
                // Im(x) fixed: z = fixedValue + i*y
                x = state.fixedValue;
                y = realPart;
            }
            
            const result = complexFunc(x, y, state.func);
            
            // Clamp extreme values for e^z
            const maxVal = 100;
            const clampedRe = Math.max(-maxVal, Math.min(maxVal, result.re));
            const clampedIm = Math.max(-maxVal, Math.min(maxVal, result.im));
            
            // Position depends on which axis is fixed
            let position;
            if (state.fixedAxisType === 'y') {
                // Im(y) fixed: (Re(z), Re(f), Im(f))
                position = new THREE.Vector3(
                    x,           // X: Re(z)
                    clampedRe,   // Y: Re(f)
                    clampedIm    // Z: Im(f)
                );
            } else {
                // Im(x) fixed: (Im(z), Re(f), Re(z))
                position = new THREE.Vector3(
                    y,           // X: Im(z)
                    clampedRe,   // Y: Re(f)
                    clampedIm    // Z: Im(f)
                );
            }
            
            points.push(position);
            
            // Add formula labels every 7 units
            if (Math.abs(realPart % 7) < 0.1 && Math.abs(realPart) > 0.1) {
                const zStr = state.fixedAxisType === 'y' 
                    ? `${realPart.toFixed(0)}+${state.fixedValue.toFixed(1)}i`
                    : `${state.fixedValue.toFixed(1)}+${realPart.toFixed(0)}i`;
                const fStr = `${clampedRe.toFixed(1)}+${clampedIm.toFixed(1)}i`;
                
                const label = createFormulaSprite(
                    position.x, 
                    position.y, 
                    `z=${zStr}, f=${fStr}`
                );
                label.position.copy(position);
                label.position.y += 2; // Offset above the curve
                scene.add(label);
                formulaLabels.push(label);
            }
            
            // Color based on |f|
            const mag = Math.sqrt(clampedRe * clampedRe + clampedIm * clampedIm);
            const t_color = Math.min(mag / 20, 1);
            let color;
            if (t_color < 0.5) {
                const s = t_color * 2;
                color = new THREE.Color(s, s, 1);
            } else {
                const s = (t_color - 0.5) * 2;
                color = new THREE.Color(1, 1 - s, 1 - s);
            }
            colors.push(color);
        }
        
        // Add tube geometry for better visibility
        const curve = new THREE.CatmullRomCurve3(points);
        curve.curveType = 'catmullrom';
        curve.tension = 0.5;
        
        const tubeGeometry = new THREE.TubeGeometry(
            curve,
            resolution * 3,
            0.15,
            16,
            false
        );
        
        // Create color attribute for tube
        const tubeColors = new Float32Array(tubeGeometry.attributes.position.count * 3);
        const tubePositions = tubeGeometry.attributes.position.array;
        
        for (let i = 0; i < tubePositions.length; i += 3) {
            const x = tubePositions[i];
            const y = tubePositions[i + 1];
            const z = tubePositions[i + 2];
            
            // Find closest point on curve to determine color
            const mag = Math.sqrt(y * y + z * z);
            const t_color = Math.min(mag / 20, 1);
            
            let color;
            if (t_color < 0.5) {
                const s = t_color * 2;
                color = new THREE.Color(s, s, 1);
            } else {
                const s = (t_color - 0.5) * 2;
                color = new THREE.Color(1, 1 - s, 1 - s);
            }
            
            tubeColors[i] = color.r;
            tubeColors[i + 1] = color.g;
            tubeColors[i + 2] = color.b;
        }
        
        tubeGeometry.setAttribute('color', new THREE.BufferAttribute(tubeColors, 3));
        
        const tubeMaterial = new THREE.MeshPhongMaterial({
            vertexColors: true,
            shininess: 60,
            specular: 0x444444
        });
        
        surface = new THREE.Mesh(tubeGeometry, tubeMaterial);
        scene.add(surface);
    }
    
    // Player controls
    const keys = {};
    const moveSpeed = 0.2;
    const runMultiplier = 1.8;
    const mouseLookSpeed = 0.003;
    const touchLookSpeed = 0.008;
    
    let pitch = 0;
    let yaw = 0;
    
    // Virtual joystick state
    const joysticks = {
        left: { active: false, x: 0, y: 0, touchId: null }
    };
    
    // Camera touch control
    let cameraTouchId = null;
    let lastTouchX = 0;
    let lastTouchY = 0;
    
    // Track where each touch started to prevent crossover
    const touchStartPositions = new Map();
    
    // Detect mobile
    state.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (state.isMobile) {
        document.getElementById('leftJoystick').classList.add('active');
    }
    
    // Joystick handlers
    let joystickBaseX = 0;
    let joystickBaseY = 0;
    
    function handleJoystickStart(e, side) {
        e.preventDefault();
        e.stopPropagation();
        
        // Don't allow joystick to start if camera touch is already active
        if (cameraTouchId !== null) {
            return;
        }
        
        const touch = e.touches[0];
        const joystick = joysticks.left;
        
        joystick.active = true;
        joystick.touchId = touch.identifier;
        
        // Mark this touch as belonging to joystick
        touchStartPositions.set(touch.identifier, 'joystick');
        
        // Store initial joystick base position
        const element = document.getElementById(side + 'Joystick');
        const rect = element.getBoundingClientRect();
        joystickBaseX = rect.left + rect.width / 2;
        joystickBaseY = rect.top + rect.height / 2;
        
        updateJoystick(touch, side);
    }
    
    function handleJoystickEnd(e, side) {
        e.stopPropagation();
        const joystick = joysticks.left;
        
        // Check if the released touch is the joystick touch
        for (let touch of e.changedTouches) {
            if (touch.identifier === joystick.touchId) {
                joystick.active = false;
                joystick.x = 0;
                joystick.y = 0;
                joystick.touchId = null;
                
                // Clean up touch tracking
                touchStartPositions.delete(touch.identifier);
                
                const handle = document.querySelector(`#${side}Joystick .joystick-handle`);
                handle.style.transform = 'translate(-50%, -50%)';
                
                // Reset joystick position to original location
                const element = document.getElementById(side + 'Joystick');
                element.style.left = '30px';
                element.style.bottom = '30px';
                element.style.transform = 'none';
            }
        }
    }
    
    function updateJoystick(touch, side) {
        const element = document.getElementById(side + 'Joystick');
        const maxRadius = 60; // Maximum distance from base before joystick moves
        const followRadius = 40; // Radius within which joystick stays centered
        
        let deltaX = touch.clientX - joystickBaseX;
        let deltaY = touch.clientY - joystickBaseY;
        
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // If finger goes beyond max radius, move the joystick base
        if (distance > maxRadius) {
            const angle = Math.atan2(deltaY, deltaX);
            const moveDistance = distance - maxRadius;
            
            // Move joystick base
            const newBaseX = joystickBaseX + Math.cos(angle) * moveDistance;
            const newBaseY = joystickBaseY + Math.sin(angle) * moveDistance;
            
            // Constrain joystick to screen bounds
            const minX = 60;
            const maxX = window.innerWidth - 60;
            const minY = 60;
            const maxY = window.innerHeight - 60;
            
            joystickBaseX = Math.max(minX, Math.min(maxX, newBaseX));
            joystickBaseY = Math.max(minY, Math.min(maxY, newBaseY));
            
            // Update element position
            element.style.left = `${joystickBaseX - 60}px`;
            element.style.bottom = `${window.innerHeight - joystickBaseY - 60}px`;
            
            // Recalculate delta from new base
            deltaX = touch.clientX - joystickBaseX;
            deltaY = touch.clientY - joystickBaseY;
        }
        
        // Clamp handle position within followRadius
        const handleDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (handleDistance > followRadius) {
            const angle = Math.atan2(deltaY, deltaX);
            deltaX = Math.cos(angle) * followRadius;
            deltaY = Math.sin(angle) * followRadius;
        }
        
        const joystick = joysticks.left;
        joystick.x = deltaX / followRadius;
        joystick.y = deltaY / followRadius;
        
        const handle = element.querySelector('.joystick-handle');
        handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
    }
    
    const leftJoystickElement = document.getElementById('leftJoystick');
    
    // Capture all touches on joystick element and prevent them from going to document
    leftJoystickElement.addEventListener('touchstart', (e) => {
        e.stopImmediatePropagation();
        handleJoystickStart(e, 'left');
    }, { passive: false, capture: true });
    
    leftJoystickElement.addEventListener('touchend', (e) => {
        e.stopImmediatePropagation();
        handleJoystickEnd(e, 'left');
    }, { passive: false, capture: true });
    
    leftJoystickElement.addEventListener('touchmove', (e) => {
        e.preventDefault();
        e.stopImmediatePropagation();
        
        // Only update if joystick is active and this is specifically the joystick's touch
        if (!joysticks.left.active) return;
        
        for (let touch of e.touches) {
            if (touch.identifier === joysticks.left.touchId && 
                touchStartPositions.get(touch.identifier) === 'joystick') {
                updateJoystick(touch, 'left');
                break; // Only process the joystick touch
            }
        }
    }, { passive: false, capture: true });
    
    // Touch controls for camera (anywhere outside joystick)
    document.addEventListener('touchstart', (e) => {
        if (!state.isMobile) return;
        
        for (let touch of e.touches) {
            // Skip if this touch is already assigned to joystick
            if (touchStartPositions.get(touch.identifier) === 'joystick') {
                continue;
            }
            
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            
            // If touch is not on joystick or UI, use for camera
            if (!element || (!element.closest('#leftJoystick') && !element.closest('#ui'))) {
                e.preventDefault(); // Prevent scrolling
                if (cameraTouchId === null) {
                    cameraTouchId = touch.identifier;
                    touchStartPositions.set(touch.identifier, 'camera');
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            }
        }
    }, { passive: false });
    
    document.addEventListener('touchmove', (e) => {
        if (!state.isMobile) return;
        
        for (let touch of e.touches) {
            // Strictly check: only process if this touch is marked as camera AND is the active camera touch
            if (touch.identifier === cameraTouchId && 
                touchStartPositions.get(touch.identifier) === 'camera') {
                e.preventDefault();
                
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;
                
                yaw -= deltaX * touchLookSpeed;
                pitch -= deltaY * touchLookSpeed;
                
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }
        }
    }, { passive: false });
    
    document.addEventListener('touchend', (e) => {
        for (let touch of e.changedTouches) {
            if (touch.identifier === cameraTouchId) {
                cameraTouchId = null;
                touchStartPositions.delete(touch.identifier);
            }
        }
    });
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        // Function switching
        if (e.key === 'q') setFunc('z2');
        if (e.key === 'e') setFunc('z3');
        if (e.key === 'r') setFunc('exp');
    });
    
    window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });
    
    // Mouse controls
    let isPointerLocked = false;
    
    const canvas = document.getElementById('canvas');
    
    canvas.addEventListener('click', () => {
        if (!state.isMobile) {
            canvas.requestPointerLock();
        }
    });
    
    // Prevent all scrolling on canvas
    canvas.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
    
    document.addEventListener('pointerlockchange', () => {
        isPointerLocked = document.pointerLockElement === canvas;
    });
    
    document.addEventListener('mousemove', (e) => {
        if (isPointerLocked) {
            yaw -= e.movementX * mouseLookSpeed;
            pitch -= e.movementY * mouseLookSpeed;
            // Remove pitch clamping for free rotation
        }
    });
    
    // UI handlers
    function setFunc(func) {
        state.func = func;
        document.getElementById('funcZ2').classList.toggle('active', func === 'z2');
        document.getElementById('funcZ3').classList.toggle('active', func === 'z3');
        document.getElementById('funcExp').classList.toggle('active', func === 'exp');
        document.getElementById('funcSin').classList.toggle('active', func === 'sin');
        document.getElementById('funcCos').classList.toggle('active', func === 'cos');
        createSurface();
    }
    
    function setFixedAxis(axisType) {
        state.fixedAxisType = axisType;
        document.getElementById('axisImX').classList.toggle('active', axisType === 'x');
        document.getElementById('axisImY').classList.toggle('active', axisType === 'y');
        
        // Update slider label
        if (axisType === 'y') {
            document.getElementById('sliderLabel').textContent = `Im(y) Âõ∫ÂÆöÂÄ§: ${state.fixedValue.toFixed(2)}`;
        } else {
            document.getElementById('sliderLabel').textContent = `Im(x) Âõ∫ÂÆöÂÄ§: ${state.fixedValue.toFixed(2)}`;
        }
        
        createSurface();
    }
    
    function toggleFormulas() {
        state.showFormulas = !state.showFormulas;
        document.getElementById('toggleFormulas').textContent = `Êï∞ÂºèË°®Á§∫: ${state.showFormulas ? 'ON' : 'OFF'}`;
        document.getElementById('toggleFormulas').classList.toggle('active', state.showFormulas);
        
        // Toggle visibility of all formula labels
        formulaLabels.forEach(label => {
            label.visible = state.showFormulas;
        });
    }
    
    document.getElementById('funcZ2').addEventListener('click', () => setFunc('z2'));
    document.getElementById('funcZ3').addEventListener('click', () => setFunc('z3'));
    document.getElementById('funcExp').addEventListener('click', () => setFunc('exp'));
    document.getElementById('funcSin').addEventListener('click', () => setFunc('sin'));
    document.getElementById('funcCos').addEventListener('click', () => setFunc('cos'));
    
    document.getElementById('axisImX').addEventListener('click', () => setFixedAxis('x'));
    document.getElementById('axisImY').addEventListener('click', () => setFixedAxis('y'));
    
    document.getElementById('toggleFormulas').addEventListener('click', toggleFormulas);
    
    document.getElementById('fullscreenBtn').addEventListener('click', () => {
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
            document.documentElement.webkitRequestFullscreen();
        }
    });
    
    document.getElementById('fixedValueSlider').addEventListener('input', (e) => {
        state.fixedValue = parseFloat(e.target.value);
        const axisLabel = state.fixedAxisType === 'y' ? 'Im(y)' : 'Im(x)';
        document.getElementById('sliderLabel').textContent = `${axisLabel} Âõ∫ÂÆöÂÄ§: ${state.fixedValue.toFixed(2)}`;
        createSurface();
    });
    
    // Update loop
    function updatePlayer() {
        // Camera-relative movement vectors
        const forward = new THREE.Vector3();
        const right = new THREE.Vector3();
        
        // Get camera's forward and right vectors
        camera.getWorldDirection(forward);
        forward.normalize();
        right.crossVectors(camera.up, forward).normalize();
        
        // Calculate speed (run if shift is held)
        const currentSpeed = keys['shift'] ? moveSpeed * runMultiplier : moveSpeed;
        
        // Keyboard movement - now uses full 3D camera direction
        if (keys['w']) camera.position.addScaledVector(forward, currentSpeed);
        if (keys['s']) camera.position.addScaledVector(forward, -currentSpeed);
        if (keys['a']) camera.position.addScaledVector(right, currentSpeed);
        if (keys['d']) camera.position.addScaledVector(right, -currentSpeed);
        if (keys[' ']) camera.position.y += currentSpeed;
        if (keys['control']) camera.position.y -= currentSpeed;
        
        // Joystick movement (mobile) - also uses full 3D direction
        if (state.isMobile && joysticks.left.active) {
            camera.position.addScaledVector(forward, -joysticks.left.y * moveSpeed * 1.5);
            camera.position.addScaledVector(right, -joysticks.left.x * moveSpeed * 1.5);
        }
        
        // Update camera rotation
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
        
        // Update info display
        const pos = camera.position;
        const fResult = complexFunc(pos.x, state.fixedValue, state.func);
        document.getElementById('info').textContent = 
            `z = ${pos.x.toFixed(2)} + ${state.fixedValue.toFixed(2)}i | ` +
            `f(z) = ${fResult.re.toFixed(2)} + ${fResult.im.toFixed(2)}i`;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        updatePlayer();
        renderer.render(scene, camera);
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Initialize
    createSurface();
    animate();
</script>
```

</body>
</html>
