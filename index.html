<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>複素関数エクスプローラー</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        overflow: hidden;
        font-family: 'Arial', sans-serif;
        touch-action: none;
    }
    
    #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
    }
    
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 100;
        max-width: 300px;
    }
    
    .button-group {
        margin: 10px 0;
    }
    
    button {
        background: rgba(100, 100, 255, 0.8);
        border: none;
        color: white;
        padding: 8px 12px;
        margin: 3px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        transition: background 0.2s;
    }
    
    button:hover {
        background: rgba(120, 120, 255, 1);
    }
    
    button.active {
        background: rgba(255, 100, 100, 0.9);
    }
    
    input[type="range"] {
        width: 100%;
        margin: 5px 0;
    }
    
    /* Virtual Joysticks */
    .joystick {
        position: absolute;
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        bottom: 30px;
        display: none;
        touch-action: none;
    }
    
    .joystick.active {
        display: block;
    }
    
    #leftJoystick {
        left: 30px;
    }
    
    .joystick-handle {
        position: absolute;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        touch-action: none;
    }
    
    #info {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 12px;
        text-align: center;
    }
    
    @media (max-width: 768px) {
        #ui {
            font-size: 11px;
            padding: 10px;
            max-width: 200px;
        }
        
        button {
            padding: 6px 8px;
            font-size: 10px;
        }
    }
</style>
```

</head>
<body>
    <canvas id="canvas"></canvas>

```
<div id="ui">
    <div><strong>複素関数エクスプローラー</strong></div>
    <div class="button-group">
        <div>関数:</div>
        <button id="funcZ2" class="active">z²</button>
        <button id="funcZ3">z³</button>
        <button id="funcExp">e^z</button>
    </div>
    <div class="button-group">
        <label id="sliderLabel">Im(z) 固定値: 0.00</label>
        <input type="range" id="fixedValueSlider" min="-5" max="5" step="0.1" value="0">
    </div>
    <div style="margin-top: 10px; font-size: 11px; opacity: 0.8;">
        <div>PC: WASD移動, マウス視点</div>
        <div>Space上昇, Ctrl下降, Shift走る</div>
    </div>
</div>

<div id="leftJoystick" class="joystick">
    <div class="joystick-handle"></div>
</div>

<div id="info">
    位置: (0.00, 0.00, 0.00) | f(z) = 0.00 + 0.00i
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Game state
    const state = {
        mode: 'real', // 'real', 'imag', 'abs'
        func: 'z2', // 'z2', 'z3', 'exp'
        fixedAxis: true,
        fixedValue: 0,
        isMobile: false
    };
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    scene.fog = new THREE.Fog(0x1a1a2e, 30, 150);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 5, 10);
    
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // Complex function computation
    function complexFunc(x, y, funcType) {
        const z = { re: x, im: y };
        let result = { re: 0, im: 0 };
        
        switch(funcType) {
            case 'z2':
                result.re = z.re * z.re - z.im * z.im;
                result.im = 2 * z.re * z.im;
                break;
            case 'z3':
                const r2 = z.re * z.re - z.im * z.im;
                const i2 = 2 * z.re * z.im;
                result.re = r2 * z.re - i2 * z.im;
                result.im = r2 * z.im + i2 * z.re;
                break;
            case 'exp':
                const expRe = Math.exp(z.re);
                result.re = expRe * Math.cos(z.im);
                result.im = expRe * Math.sin(z.im);
                break;
        }
        
        return result;
    }
    
    function getHeight(x, z) {
        // x = Re(z), z = Im(z) in 3D space
        const result = complexFunc(x, z, state.func);
        
        switch(state.mode) {
            case 'real':
                return result.re;
            case 'imag':
                return result.im;
            case 'abs':
                return Math.sqrt(result.re * result.re + result.im * result.im);
        }
    }
    
    // Create surface
    let surface;
    
    function createSurface() {
        if (surface) {
            scene.remove(surface);
            surface.geometry.dispose();
            surface.material.dispose();
        }
        
        if (!state.fixedAxis) {
            // Non-fixed mode: (Re(z), Im(z), f(z)) surface
            const resolution = state.isMobile ? 50 : 80;
            const size = 40;
            const geometry = new THREE.PlaneGeometry(size, size, resolution, resolution);
            
            const positions = geometry.attributes.position.array;
            const colors = [];
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];     // Re(z)
                const z = positions[i + 1]; // Im(z)
                
                const height = getHeight(x, z);
                positions[i + 2] = Math.max(-10, Math.min(10, height));
                
                // Color based on height - blue to white to red gradient
                const t = (height + 10) / 20; // normalize to 0-1
                let color;
                if (t < 0.5) {
                    // Blue to white
                    const s = t * 2;
                    color = new THREE.Color(s, s, 1);
                } else {
                    // White to red
                    const s = (t - 0.5) * 2;
                    color = new THREE.Color(1, 1 - s, 1 - s);
                }
                colors.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 30,
                wireframe: false
            });
            
            surface = new THREE.Mesh(geometry, material);
            surface.rotation.x = -Math.PI / 2;
            scene.add(surface);
            
            // Add wireframe
            wireframeObj = new THREE.LineSegments(
                new THREE.WireframeGeometry(geometry),
                new THREE.LineBasicMaterial({ color: 0x888888, opacity: 0.5, transparent: true })
            );
            wireframeObj.rotation.x = -Math.PI / 2;
            scene.add(wireframeObj);
        } else {
            // Fixed mode: Im(z) = fixedValue, draw (Re(z), Re(f), Im(f)) curve
            const resolution = state.isMobile ? 300 : 500;
            const range = 20;
            
            const points = [];
            const colors = [];
            
            for (let i = 0; i <= resolution; i++) {
                const t = (i / resolution) * 2 - 1;
                const reZ = t * range; // Re(z) from -range to +range
                const imZ = state.fixedValue; // Im(z) fixed
                
                const result = complexFunc(reZ, imZ, state.func);
                
                // Position: (Re(z), Re(f), Im(f))
                points.push(new THREE.Vector3(
                    reZ,           // X: Re(z)
                    result.re,     // Y: Re(f)
                    result.im      // Z: Im(f)
                ));
                
                // Color based on |f|
                const mag = Math.sqrt(result.re * result.re + result.im * result.im);
                const t_color = Math.min(mag / 10, 1);
                let color;
                if (t_color < 0.5) {
                    const s = t_color * 2;
                    color = new THREE.Color(s, s, 1);
                } else {
                    const s = (t_color - 0.5) * 2;
                    color = new THREE.Color(1, 1 - s, 1 - s);
                }
                colors.push(color);
            }
            
            // Add tube geometry for better visibility
            const curve = new THREE.CatmullRomCurve3(points);
            curve.curveType = 'catmullrom';
            curve.tension = 0.5;
            
            const tubeGeometry = new THREE.TubeGeometry(
                curve,
                resolution * 2,
                0.15,
                16,
                false
            );
            
            // Create color attribute for tube
            const tubeColors = new Float32Array(tubeGeometry.attributes.position.count * 3);
            const tubePositions = tubeGeometry.attributes.position.array;
            
            for (let i = 0; i < tubePositions.length; i += 3) {
                const x = tubePositions[i];
                const y = tubePositions[i + 1];
                const z = tubePositions[i + 2];
                
                // Find closest point on curve to determine color
                const mag = Math.sqrt(y * y + z * z);
                const t_color = Math.min(mag / 10, 1);
                
                let color;
                if (t_color < 0.5) {
                    const s = t_color * 2;
                    color = new THREE.Color(s, s, 1);
                } else {
                    const s = (t_color - 0.5) * 2;
                    color = new THREE.Color(1, 1 - s, 1 - s);
                }
                
                tubeColors[i] = color.r;
                tubeColors[i + 1] = color.g;
                tubeColors[i + 2] = color.b;
            }
            
            tubeGeometry.setAttribute('color', new THREE.BufferAttribute(tubeColors, 3));
            
            const tubeMaterial = new THREE.MeshPhongMaterial({
                vertexColors: true,
                shininess: 60,
                specular: 0x444444
            });
            
            surface = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(surface);
        }
    }
    
    // Player controls
    const keys = {};
    const moveSpeed = 0.2;
    const runMultiplier = 1.8;
    const mouseLookSpeed = 0.003;
    const touchLookSpeed = 0.008;
    
    let pitch = 0;
    let yaw = 0;
    
    // Virtual joystick state
    const joysticks = {
        left: { active: false, x: 0, y: 0, touchId: null }
    };
    
    // Camera touch control
    let cameraTouchId = null;
    let lastTouchX = 0;
    let lastTouchY = 0;
    
    // Detect mobile
    state.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (state.isMobile) {
        document.getElementById('leftJoystick').classList.add('active');
    }
    
    // Joystick handlers
    function handleJoystickStart(e, side) {
        e.preventDefault();
        const touch = e.touches[0];
        const joystick = side === 'left' ? joysticks.left : joysticks.right;
        
        joystick.active = true;
        joystick.touchId = touch.identifier;
        updateJoystick(touch, side);
    }
    
    function handleJoystickMove(e) {
        e.preventDefault();
        for (let touch of e.touches) {
            if (touch.identifier === joysticks.left.touchId) {
                updateJoystick(touch, 'left');
            } else if (touch.identifier === cameraTouchId) {
                // Camera control
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;
                
                yaw -= deltaX * touchLookSpeed;
                pitch -= deltaY * touchLookSpeed;
                // Remove pitch clamping for free rotation
                
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }
        }
    }
    
    function handleJoystickEnd(e, side) {
        const joystick = side === 'left' ? joysticks.left : joysticks.right;
        joystick.active = false;
        joystick.x = 0;
        joystick.y = 0;
        joystick.touchId = null;
        
        const handle = document.querySelector(`#${side}Joystick .joystick-handle`);
        handle.style.transform = 'translate(-50%, -50%)';
    }
    
    function updateJoystick(touch, side) {
        const element = document.getElementById(side + 'Joystick');
        const rect = element.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        let deltaX = touch.clientX - centerX;
        let deltaY = touch.clientY - centerY;
        
        const maxDistance = 35;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > maxDistance) {
            deltaX = (deltaX / distance) * maxDistance;
            deltaY = (deltaY / distance) * maxDistance;
        }
        
        const joystick = side === 'left' ? joysticks.left : joysticks.right;
        joystick.x = deltaX / maxDistance;
        joystick.y = deltaY / maxDistance;
        
        const handle = element.querySelector('.joystick-handle');
        handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
    }
    
    document.getElementById('leftJoystick').addEventListener('touchstart', (e) => handleJoystickStart(e, 'left'));
    
    // Touch controls for camera (anywhere outside joystick)
    document.addEventListener('touchstart', (e) => {
        if (!state.isMobile) return;
        
        for (let touch of e.touches) {
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            
            // If touch is not on joystick or UI, use for camera
            if (!element.closest('#leftJoystick') && !element.closest('#ui')) {
                if (cameraTouchId === null) {
                    cameraTouchId = touch.identifier;
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            }
        }
    });
    document.addEventListener('touchmove', handleJoystickMove);
    
    document.getElementById('leftJoystick').addEventListener('touchend', (e) => handleJoystickEnd(e, 'left'));
    
    document.addEventListener('touchend', (e) => {
        for (let touch of e.changedTouches) {
            if (touch.identifier === cameraTouchId) {
                cameraTouchId = null;
            }
        }
    });
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        // Function switching
        if (e.key === 'q') setFunc('z2');
        if (e.key === 'e') setFunc('z3');
        if (e.key === 'r') setFunc('exp');
    });
    
    window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });
    
    // Mouse controls
    let isPointerLocked = false;
    
    canvas.addEventListener('click', () => {
        if (!state.isMobile) {
            canvas.requestPointerLock();
        }
    });
    
    document.addEventListener('pointerlockchange', () => {
        isPointerLocked = document.pointerLockElement === canvas;
    });
    
    document.addEventListener('mousemove', (e) => {
        if (isPointerLocked) {
            yaw -= e.movementX * mouseLookSpeed;
            pitch -= e.movementY * mouseLookSpeed;
            // Remove pitch clamping for free rotation
        }
    });
    
    // UI handlers
    function setFunc(func) {
        state.func = func;
        document.getElementById('funcZ2').classList.toggle('active', func === 'z2');
        document.getElementById('funcZ3').classList.toggle('active', func === 'z3');
        document.getElementById('funcExp').classList.toggle('active', func === 'exp');
        createSurface();
    }
    
    document.getElementById('funcZ2').addEventListener('click', () => setFunc('z2'));
    document.getElementById('funcZ3').addEventListener('click', () => setFunc('z3'));
    document.getElementById('funcExp').addEventListener('click', () => setFunc('exp'));
    
    document.getElementById('fixedValueSlider').addEventListener('input', (e) => {
        state.fixedValue = parseFloat(e.target.value);
        document.getElementById('sliderLabel').textContent = `Im(z) 固定値: ${state.fixedValue.toFixed(2)}`;
        createSurface();
    });
    
    // Update loop
    function updatePlayer() {
        // Camera-relative movement vectors
        const forward = new THREE.Vector3();
        const right = new THREE.Vector3();
        
        // Get camera's forward and right vectors
        camera.getWorldDirection(forward);
        right.crossVectors(camera.up, forward).normalize();
        
        // For horizontal movement, we want to move parallel to the ground
        const forwardFlat = new THREE.Vector3(forward.x, 0, forward.z).normalize();
        const rightFlat = new THREE.Vector3(right.x, 0, right.z).normalize();
        
        // Calculate speed (run if shift is held)
        const currentSpeed = keys['shift'] ? moveSpeed * runMultiplier : moveSpeed;
        
        // Keyboard movement
        if (keys['w']) camera.position.addScaledVector(forwardFlat, currentSpeed);
        if (keys['s']) camera.position.addScaledVector(forwardFlat, -currentSpeed);
        if (keys['a']) camera.position.addScaledVector(rightFlat, currentSpeed);
        if (keys['d']) camera.position.addScaledVector(rightFlat, -currentSpeed);
        if (keys[' ']) camera.position.y += currentSpeed;
        if (keys['control']) camera.position.y -= currentSpeed;
        
        // Joystick movement (mobile)
        if (state.isMobile && joysticks.left.active) {
            camera.position.addScaledVector(forwardFlat, -joysticks.left.y * moveSpeed * 1.5);
            camera.position.addScaledVector(rightFlat, joysticks.left.x * moveSpeed * 1.5);
        }
        
        // Update camera rotation
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
        
        // Update info display
        const pos = camera.position;
        const fResult = complexFunc(pos.x, state.fixedValue, state.func);
        document.getElementById('info').textContent = 
            `z = ${pos.x.toFixed(2)} + ${state.fixedValue.toFixed(2)}i | ` +
            `f(z) = ${fResult.re.toFixed(2)} + ${fResult.im.toFixed(2)}i`;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        updatePlayer();
        renderer.render(scene, camera);
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Initialize
    createSurface();
    animate();
</script>
```

</body>
</html>
