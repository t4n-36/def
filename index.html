<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>複素関数エクスプローラー</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overscroll-behavior: none;
        }

```
    html {
        overflow: hidden;
        touch-action: none;
        overscroll-behavior: none;
        height: 100vh;
        height: 100dvh; /* Dynamic viewport height */
    }
    
    body {
        overflow: hidden;
        font-family: 'Arial', sans-serif;
        touch-action: none;
        overscroll-behavior: none;
        height: 100vh;
        height: 100dvh;
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    
    #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 0;
    }
    
    #ui {
        position: fixed;
        top: 10px;
        left: 10px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 100;
        max-width: 300px;
        transition: transform 0.3s ease;
        pointer-events: auto;
    }
    
    #ui.collapsed {
        transform: translateX(-330px);
    }
    
    #uiToggle {
        position: fixed;
        top: 20px;
        left: calc(10px + 300px + 15px + 10px);
        color: white;
        background: rgba(100, 100, 255, 0.9);
        border: 2px solid rgba(255, 255, 255, 0.5);
        padding: 12px 18px;
        border-radius: 8px;
        font-size: 20px;
        font-weight: bold;
        cursor: pointer;
        z-index: 9999;
        transition: left 0.3s ease;
        pointer-events: auto;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        touch-action: manipulation;
        -webkit-tap-highlight-color: rgba(255,255,255,0.3);
    }
    
    #uiToggle.collapsed {
        left: 10px;
        background: rgba(100, 255, 100, 0.9);
    }
    
    .button-group {
        margin: 10px 0;
    }
    
    button {
        background: rgba(100, 100, 255, 0.8);
        border: none;
        color: white;
        padding: 8px 12px;
        margin: 3px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        transition: background 0.2s;
    }
    
    button:hover {
        background: rgba(120, 120, 255, 1);
    }
    
    button.active {
        background: rgba(255, 100, 100, 0.9);
    }
    
    .func-btn {
        background: rgba(240, 240, 250, 0.95);
        border: 1px solid rgba(200, 200, 220, 0.5);
        color: #333;
        padding: 10px 4px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: background 0.15s;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        pointer-events: auto;
        touch-action: manipulation;
    }
    
    .func-btn:hover {
        background: rgba(220, 220, 240, 1);
    }
    
    .func-btn:active {
        background: rgba(200, 200, 230, 1);
        transform: scale(0.97);
    }
    
    input[type="range"] {
        width: 100%;
        margin: 5px 0;
    }
    
    /* Virtual Joysticks */
    .joystick {
        position: fixed;
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        bottom: 30px;
        display: none;
        touch-action: none;
        z-index: 1000;
        transition: left 0.1s ease-out, bottom 0.1s ease-out;
    }
    
    .joystick.active {
        display: block;
    }
    
    #leftJoystick {
        left: 30px;
    }
    
    .joystick-handle {
        position: absolute;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        touch-action: none;
    }
    
    #info {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 12px;
        text-align: center;
        z-index: 100;
        pointer-events: none;
    }
    
    #coordSystem {
        position: fixed;
        top: 10px;
        right: 10px;
        width: 100px;
        height: 100px;
        pointer-events: none;
        z-index: 100;
    }
    
    @media (max-width: 768px) {
        #ui {
            font-size: 11px;
            padding: 10px;
            max-width: 200px;
        }
        
        button {
            padding: 6px 8px;
            font-size: 10px;
        }
    }
</style>
```

</head>
<body>
    <canvas id="canvas"></canvas>

```
<div id="ui">
    <div><strong>複素関数エクスプローラー</strong></div>
    <div id="currentFunc" style="font-size: 12px; color: #88ff88; margin: 5px 0; padding: 5px; background: rgba(0,100,0,0.3); border-radius: 4px;">
        (a+bi)² = α+βi [b=0.00固定]
    </div>
    <div class="button-group">
        <div>関数:</div>
        <button id="funcZ2" class="active">z²</button>
        <button id="funcZ3">z³</button>
        <button id="funcExp">e^z</button>
        <button id="funcSin">sin(z)</button>
        <button id="funcCos">cos(z)</button>
    </div>
    <div class="button-group">
        <button id="openCustomKeyboard" style="width: 100%; background: rgba(150,100,255,0.6);">カスタム関数を構築</button>
    </div>
    <div class="button-group">
        <div>固定軸:</div>
        <button id="axisImX">Re(入力)固定</button>
        <button id="axisImY" class="active">Im(入力)固定</button>
    </div>
    <div class="button-group">
        <label id="sliderLabel">Im 固定値: 0.00</label>
        <div style="display: flex; align-items: center; gap: 5px;">
            <button id="decreaseFixed" style="padding: 5px 10px;">◀</button>
            <input type="range" id="fixedValueSlider" min="-5" max="5" step="0.1" value="0" style="flex: 1;">
            <button id="increaseFixed" style="padding: 5px 10px;">▶</button>
        </div>
    </div>
    <div class="button-group">
        <button id="toggleFormulas">数式表示: OFF</button>
        <button id="keepGraph" style="background: rgba(100, 200, 100, 0.5);">グラフ保持</button>
    </div>
    <div style="margin-top: 10px; font-size: 11px; opacity: 0.8;">
        <div>PC: WASD移動, マウス視点</div>
        <div>Space上昇, Ctrl下降, Shift走る</div>
    </div>
    <div id="keptGraphs" style="margin-top: 10px; max-height: 150px; overflow-y: auto;">
        <!-- Kept graphs will appear here -->
    </div>
</div>

<button id="uiToggle">◀</button>

<div id="leftJoystick" class="joystick">
    <div class="joystick-handle"></div>
</div>

<div id="info">
    位置: (0.00, 0.00, 0.00) | f(z) = 0.00 + 0.00i
</div>

<div id="coordSystem"></div>

<!-- Custom Function Keyboard Modal -->
<div id="customKeyboardModal" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: rgba(255,255,255,0.98); padding: 15px; padding-bottom: max(15px, env(safe-area-inset-bottom)); box-shadow: 0 -4px 20px rgba(0,0,0,0.3); z-index: 10000; transform: translateY(100%); transition: transform 0.3s ease; pointer-events: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <div style="font-size: 14px; font-weight: bold; color: #333;">カスタム関数</div>
        <button id="closeKeyboard" style="background: rgba(200,50,50,0.8); color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 14px; pointer-events: auto;">閉じる</button>
    </div>
    <div id="customFuncDisplay" style="width: 100%; padding: 12px; background: #f5f5f5; border: 2px solid #ddd; border-radius: 8px; color: #333; font-size: 18px; min-height: 50px; margin-bottom: 10px; font-family: monospace; overflow-x: auto;">
        
    </div>
    <!-- Row 1: x, y, π, e, numbers -->
    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; margin-bottom: 3px;">
        <button class="func-btn" data-func="x">x</button>
        <button class="func-btn" data-func="y">y</button>
        <button class="func-btn" data-func="π">π</button>
        <button class="func-btn" data-func="e">e</button>
        <button class="func-btn" data-func="7">7</button>
        <button class="func-btn" data-func="8">8</button>
        <button class="func-btn" data-func="9">9</button>
        <button class="func-btn" data-func="*">×</button>
    </div>
    <!-- Row 2: powers and numbers -->
    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; margin-bottom: 3px;">
        <button class="func-btn" data-func="^2">x²</button>
        <button class="func-btn" data-func="^">xʸ</button>
        <button class="func-btn" data-func="sqrt(">√</button>
        <button class="func-btn" data-func="abs">|x|</button>
        <button class="func-btn" data-func="4">4</button>
        <button class="func-btn" data-func="5">5</button>
        <button class="func-btn" data-func="6">6</button>
        <button class="func-btn" data-func="+">+</button>
    </div>
    <!-- Row 3: comparison and numbers -->
    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; margin-bottom: 3px;">
        <button class="func-btn" data-func="<">&lt;</button>
        <button class="func-btn" data-func=">">&gt;</button>
        <button class="func-btn" data-func="!">!</button>
        <button class="func-btn" data-func="/">/</button>
        <button class="func-btn" data-func="1">1</button>
        <button class="func-btn" data-func="2">2</button>
        <button class="func-btn" data-func="3">3</button>
        <button class="func-btn" data-func="-">−</button>
    </div>
    <!-- Row 4: special functions and numbers -->
    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; margin-bottom: 3px;">
        <button class="func-btn" data-func="e^">eˣ</button>
        <button class="func-btn" data-func="10^">10ˣ</button>
        <button class="func-btn" data-func="sqrt">√x</button>
        <button class="func-btn" data-func="!">x!</button>
        <button class="func-btn" data-func="0">0</button>
        <button class="func-btn" data-func="(">(</button>
        <button class="func-btn" data-func=")">)</button>
        <button class="func-btn" data-func="clear" style="background: rgba(150,150,150,0.7);">⌫</button>
    </div>
    <!-- Row 5: trig functions -->
    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 3px; margin-bottom: 3px;">
        <button class="func-btn" data-func="sin(">sin</button>
        <button class="func-btn" data-func="cos(">cos</button>
        <button class="func-btn" data-func="tan(">tan</button>
        <button class="func-btn" data-func="%">%</button>
        <button class="func-btn" data-func=".">.</button>
        <button class="func-btn" data-func=",">,</button>
        <button class="func-btn" data-func="^">^</button>
        <button id="applyCustom" style="background: rgba(100,200,100,0.9); padding: 12px; font-size: 14px; border: 1px solid rgba(80,180,80,0.5); border-radius: 6px; color: white; cursor: pointer; font-weight: bold;">適用</button>
    </div>
    <!-- Row 6: inverse trig -->
    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px;">
        <button class="func-btn" data-func="ln(">ln</button>
        <button class="func-btn" data-func="log(">log</button>
        <button class="func-btn" data-func="exp(">exp</button>
        <button class="func-btn" data-func="clearAll" style="background: rgba(200,50,50,0.7); color: white;">クリア</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Game state
    const state = {
        mode: 'real', // 'real', 'imag', 'abs'
        func: 'z2', // 'z2', 'z3', 'exp', 'sin', 'cos', 'custom'
        customFuncStr: '', // User's custom function string
        fixedAxis: true,
        fixedAxisType: 'y', // 'x' or 'y' - which axis to fix (x=Re, y=Im)
        fixedValue: 0,
        isMobile: false,
        showFormulas: false
    };
    
    const keptGraphs = []; // Array to store kept graph meshes
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    scene.fog = new THREE.Fog(0x1a1a2e, 30, 150);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 5, 10);
    
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // Add grid and axes
    function createAxesAndGrid() {
        const gridSize = 200;
        const gridDivisions = 200; // 1 unit per division now
        
        // Grid on XZ plane (ground)
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // Main axes
        const axesHelper = new THREE.AxesHelper(25);
        scene.add(axesHelper);
        
        // Create thicker colored axes
        const axesMaterial = {
            x: new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }),
            y: new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 }),
            z: new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2 })
        };
        
        // X axis (red) - Re(z)
        const xGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-100, 0, 0),
            new THREE.Vector3(100, 0, 0)
        ]);
        const xAxis = new THREE.Line(xGeometry, axesMaterial.x);
        scene.add(xAxis);
        
        // Y axis (green) - Re(f) or Im(f)
        const yGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -100, 0),
            new THREE.Vector3(0, 100, 0)
        ]);
        const yAxis = new THREE.Line(yGeometry, axesMaterial.y);
        scene.add(yAxis);
        
        // Z axis (blue) - Im(z)
        const zGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, -100),
            new THREE.Vector3(0, 0, 100)
        ]);
        const zAxis = new THREE.Line(zGeometry, axesMaterial.z);
        scene.add(zAxis);
        
        // Add tick marks every 1 unit
        const tickSize = 0.2;
        const tickMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
        
        for (let i = -100; i <= 100; i += 1) {
            if (Math.abs(i) < 0.01) continue; // Skip origin
            
            // X axis ticks
            const xTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(i, -tickSize, 0),
                new THREE.Vector3(i, tickSize, 0)
            ]);
            scene.add(new THREE.Line(xTickGeom, tickMaterial));
            
            // Y axis ticks
            const yTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-tickSize, i, 0),
                new THREE.Vector3(tickSize, i, 0)
            ]);
            scene.add(new THREE.Line(yTickGeom, tickMaterial));
            
            // Z axis ticks
            const zTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -tickSize, i),
                new THREE.Vector3(0, tickSize, i)
            ]);
            scene.add(new THREE.Line(zTickGeom, tickMaterial));
        }
        
        // Add spheres and text labels at every 5 units
        const sphereGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        // Create canvas for text labels
        function createTextSprite(text, color = '#ffffff') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            
            context.fillStyle = color;
            context.font = 'Bold 40px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 64, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 1, 1);
            
            return sprite;
        }
        
        for (let i = -100; i <= 100; i += 5) {
            if (i === 0) continue;
            
            // X axis markers
            const xSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            xSphere.position.set(i, 0, 0);
            scene.add(xSphere);
            
            const xLabel = createTextSprite(i.toString(), '#ff8888');
            xLabel.position.set(i, -1.5, 0);
            scene.add(xLabel);
            
            // Y axis markers
            const ySphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            ySphere.position.set(0, i, 0);
            scene.add(ySphere);
            
            const yLabel = createTextSprite(i.toString(), '#88ff88');
            yLabel.position.set(-1.5, i, 0);
            scene.add(yLabel);
            
            // Z axis markers
            const zSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            zSphere.position.set(0, 0, i);
            scene.add(zSphere);
            
            const zLabel = createTextSprite(i.toString(), '#8888ff');
            zLabel.position.set(0, -1.5, i);
            scene.add(zLabel);
        }
    }
    
    createAxesAndGrid();
    
    // Create coordinate system display as static 2D image
    const coordCanvas = document.createElement('canvas');
    coordCanvas.width = 100;
    coordCanvas.height = 100;
    coordCanvas.style.borderRadius = '8px';
    document.getElementById('coordSystem').appendChild(coordCanvas);
    
    const coordCtx = coordCanvas.getContext('2d');
    
    function drawCoordSystem() {
        coordCtx.clearRect(0, 0, 100, 100);
        
        const centerX = 30;
        const centerY = 60;
        const axisLen = 35;
        
        coordCtx.lineWidth = 2;
        coordCtx.lineCap = 'round';
        
        // Z axis (blue) - diagonal down-left
        coordCtx.strokeStyle = '#4444ff';
        coordCtx.beginPath();
        coordCtx.moveTo(centerX, centerY);
        coordCtx.lineTo(centerX - 20, centerY + 20);
        coordCtx.stroke();
        
        // Arrow for Z
        coordCtx.beginPath();
        coordCtx.moveTo(centerX - 20, centerY + 20);
        coordCtx.lineTo(centerX - 17, centerY + 17);
        coordCtx.stroke();
        coordCtx.beginPath();
        coordCtx.moveTo(centerX - 20, centerY + 20);
        coordCtx.lineTo(centerX - 17, centerY + 21);
        coordCtx.stroke();
        
        // X axis (red) - horizontal right
        coordCtx.strokeStyle = '#ff4444';
        coordCtx.beginPath();
        coordCtx.moveTo(centerX, centerY);
        coordCtx.lineTo(centerX + axisLen, centerY);
        coordCtx.stroke();
        
        // Arrow for X
        coordCtx.beginPath();
        coordCtx.moveTo(centerX + axisLen, centerY);
        coordCtx.lineTo(centerX + axisLen - 6, centerY - 3);
        coordCtx.stroke();
        coordCtx.beginPath();
        coordCtx.moveTo(centerX + axisLen, centerY);
        coordCtx.lineTo(centerX + axisLen - 6, centerY + 3);
        coordCtx.stroke();
        
        // Y axis (green) - vertical up
        coordCtx.strokeStyle = '#44ff44';
        coordCtx.beginPath();
        coordCtx.moveTo(centerX, centerY);
        coordCtx.lineTo(centerX, centerY - axisLen);
        coordCtx.stroke();
        
        // Arrow for Y
        coordCtx.beginPath();
        coordCtx.moveTo(centerX, centerY - axisLen);
        coordCtx.lineTo(centerX - 3, centerY - axisLen + 6);
        coordCtx.stroke();
        coordCtx.beginPath();
        coordCtx.moveTo(centerX, centerY - axisLen);
        coordCtx.lineTo(centerX + 3, centerY - axisLen + 6);
        coordCtx.stroke();
        
        // Labels
        coordCtx.font = 'bold 11px Arial';
        
        coordCtx.fillStyle = '#ff4444';
        coordCtx.fillText('X', centerX + axisLen + 3, centerY + 4);
        
        coordCtx.fillStyle = '#44ff44';
        coordCtx.fillText('Y', centerX + 3, centerY - axisLen - 3);
        
        coordCtx.fillStyle = '#4444ff';
        coordCtx.font = 'bold 9px Arial';
        const zLabel = state.fixedAxisType === 'y' ? 'Z:Im(y)' : 'Z:Im(x)';
        coordCtx.fillText(zLabel, centerX - 28, centerY + 32);
    }
    
    drawCoordSystem();
    
    // Complex function computation
    function complexFunc(x, y, funcType) {
        const z = { re: x, im: y };
        let result = { re: 0, im: 0 };
        
        switch(funcType) {
            case 'z2':
                // z^2 = (x+iy)^2 = x^2 - y^2 + 2xyi
                result.re = z.re * z.re - z.im * z.im;
                result.im = 2 * z.re * z.im;
                break;
            case 'z3':
                // z^3 = z^2 * z
                const z2_re = z.re * z.re - z.im * z.im;
                const z2_im = 2 * z.re * z.im;
                result.re = z2_re * z.re - z2_im * z.im;
                result.im = z2_re * z.im + z2_im * z.re;
                break;
            case 'exp':
                // e^z = e^(x+iy) = e^x * (cos(y) + i*sin(y))
                const expRe = Math.exp(z.re);
                result.re = expRe * Math.cos(z.im);
                result.im = expRe * Math.sin(z.im);
                break;
            case 'sin':
                // sin(z) = sin(x+iy) = sin(x)cosh(y) + i*cos(x)sinh(y)
                result.re = Math.sin(z.re) * Math.cosh(z.im);
                result.im = Math.cos(z.re) * Math.sinh(z.im);
                break;
            case 'cos':
                // cos(z) = cos(x+iy) = cos(x)cosh(y) - i*sin(x)sinh(y)
                result.re = Math.cos(z.re) * Math.cosh(z.im);
                result.im = -Math.sin(z.re) * Math.sinh(z.im);
                break;
            case 'custom':
                // Evaluate custom function
                try {
                    result = evaluateCustomFunction(state.customFuncStr, z.re, z.im);
                } catch (e) {
                    console.error('Custom function error:', e);
                    result = { re: 0, im: 0 };
                }
                break;
        }
        
        return result;
    }
    
    // Evaluate custom function string
    function evaluateCustomFunction(funcStr, re, im) {
        const z = { re, im };
        
        // Complex operations
        const add = (a, b) => ({ re: a.re + b.re, im: a.im + b.im });
        const sub = (a, b) => ({ re: a.re - b.re, im: a.im - b.im });
        const mul = (a, b) => ({ re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re });
        const div = (a, b) => {
            const d = b.re * b.re + b.im * b.im;
            return d === 0 ? {re:0,im:0} : { re: (a.re*b.re + a.im*b.im)/d, im: (a.im*b.re - a.re*b.im)/d };
        };
        const pow = (z, n) => {
            const r = Math.sqrt(z.re**2 + z.im**2);
            if (r === 0) return {re:0,im:0};
            const theta = Math.atan2(z.im, z.re);
            const newR = Math.exp(n * Math.log(r));
            const newTheta = n * theta;
            return { re: newR * Math.cos(newTheta), im: newR * Math.sin(newTheta) };
        };
        const cExp = (z) => { const e = Math.exp(z.re); return {re: e*Math.cos(z.im), im: e*Math.sin(z.im)}; };
        const cSin = (z) => ({re: Math.sin(z.re)*Math.cosh(z.im), im: Math.cos(z.re)*Math.sinh(z.im)});
        const cCos = (z) => ({re: Math.cos(z.re)*Math.cosh(z.im), im: -Math.sin(z.re)*Math.sinh(z.im)});
        const cTan = (z) => div(cSin(z), cCos(z));
        const cLn = (z) => {
            const r = Math.sqrt(z.re**2 + z.im**2);
            return r === 0 ? {re:-Infinity,im:0} : {re: Math.log(r), im: Math.atan2(z.im,z.re)};
        };
        
        try {
            let str = funcStr.trim().replace(/\s+/g, '');
            
            // Normalize symbols BEFORE variable replacement
            str = str.replace(/√\(/g, 'sqrt(');
            str = str.replace(/√/g, 'sqrt(') + (str.includes('√') && !str.includes('(') ? ')' : '');
            str = str.replace(/×/g, '*').replace(/÷/g, '/').replace(/−/g, '-');
            str = str.replace(/²/g, '^2').replace(/³/g, '^3').replace(/⁴/g, '^4');
            
            // NOW replace variables
            str = str.replace(/[xyz]/gi, 'V');
            
            // Recursive evaluator with proper operator precedence
            let tempStore = {};
            let tempCounter = 0;
            
            function eval_(expr) {
                expr = expr.trim();
                if (!expr) return {re:0,im:0};
                
                // Check temp store
                if (tempStore[expr]) return tempStore[expr];
                
                // Handle parentheses and functions
                while (true) {
                    let match = expr.match(/([a-z]+)?\(([^()]+)\)/i);
                    if (!match) break;
                    
                    const func = (match[1] || '').toLowerCase();
                    const inner = match[2];
                    const innerVal = eval_(inner);
                    
                    let result;
                    if (func === 'sin') result = cSin(innerVal);
                    else if (func === 'cos') result = cCos(innerVal);
                    else if (func === 'tan') result = cTan(innerVal);
                    else if (func === 'exp') result = cExp(innerVal);
                    else if (func === 'ln') result = cLn(innerVal);
                    else if (func === 'log') result = div(cLn(innerVal), {re:Math.log(10),im:0});
                    else if (func === 'sqrt') result = pow(innerVal, 0.5);
                    else result = innerVal;
                    
                    const temp = `T${tempCounter++}`;
                    tempStore[temp] = result;
                    expr = expr.replace(match[0], temp);
                }
                
                // Addition/Subtraction (lowest precedence)
                for (let i = expr.length - 1; i > 0; i--) {
                    if (expr[i] === '+') {
                        return add(eval_(expr.slice(0,i)), eval_(expr.slice(i+1)));
                    }
                    if (expr[i] === '-' && /[0-9VT)]/.test(expr[i-1])) {
                        return sub(eval_(expr.slice(0,i)), eval_(expr.slice(i+1)));
                    }
                }
                
                // Multiplication/Division
                for (let i = expr.length - 1; i > 0; i--) {
                    if (expr[i] === '*') return mul(eval_(expr.slice(0,i)), eval_(expr.slice(i+1)));
                    if (expr[i] === '/') return div(eval_(expr.slice(0,i)), eval_(expr.slice(i+1)));
                }
                
                // Exponentiation (highest precedence)
                const powIdx = expr.indexOf('^');
                if (powIdx > 0) {
                    const base = eval_(expr.slice(0, powIdx));
                    const exp = parseFloat(expr.slice(powIdx+1));
                    return isNaN(exp) ? {re:0,im:0} : pow(base, exp);
                }
                
                // Constants and variables
                if (expr === 'V') return z;
                if (expr === 'e') return {re: Math.E, im:0};
                if (expr === 'π' || expr.toLowerCase() === 'pi') return {re: Math.PI, im:0};
                
                const num = parseFloat(expr);
                return isNaN(num) ? {re:0,im:0} : {re:num, im:0};
            }
            
            return eval_(str);
            
        } catch (e) {
            console.error('Parse error:', e, 'Input:', funcStr);
            return {re:0,im:0};
        }
    }
    
    function getHeight(x, z) {
        // x = Re(z), z = Im(z) in 3D space
        const result = complexFunc(x, z, state.func);
        
        switch(state.mode) {
            case 'real':
                return result.re;
            case 'imag':
                return result.im;
            case 'abs':
                return Math.sqrt(result.re * result.re + result.im * result.im);
        }
    }
    
    // Create surface
    let surface;
    let formulaLabels = []; // Store formula labels for toggling
    
    function createSurface() {
        if (surface) {
            scene.remove(surface);
            surface.geometry.dispose();
            surface.material.dispose();
        }
        
        // Remove old formula labels
        formulaLabels.forEach(label => scene.remove(label));
        formulaLabels = [];
        
        // Check if custom function is valid
        if (state.func === 'custom' && !state.customFuncStr) {
            console.warn('No custom function defined');
            return; // Don't draw anything
        }
        
        // Fixed mode: Im(z) = fixedValue, draw (Re(z), Re(f), Im(f)) curve
        const resolution = state.isMobile ? 800 : 1200;
        const range = 40;
        
        const points = [];
        const colors = [];
        const labeledPositions = new Set(); // Track labeled positions
        let allZero = true; // Check if function returns all zeros
        
        // Helper function to create formula text sprite
        function createFormulaSprite(x, y, text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 96;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = '#ffffff';
            context.font = 'Bold 28px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 256, 48);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(6, 1.2, 1);
            sprite.visible = state.showFormulas;
            
            return sprite;
        }
        
        // Helper to format complex number nicely
        function formatComplex(re, im, usePi = false) {
            const epsilon = 0.01;
            
            // Handle π notation for sin/cos
            if (usePi) {
                const rePi = re / Math.PI;
                const imPi = im / Math.PI;
                
                // Check if pure real
                if (Math.abs(im) < epsilon) {
                    if (Math.abs(re) < epsilon) return '0';
                    if (Math.abs(rePi - Math.round(rePi)) < 0.1) {
                        const val = Math.round(rePi);
                        if (val === 1) return 'π';
                        if (val === -1) return '-π';
                        if (val === 0) return '0';
                        return val + 'π';
                    }
                    return re.toFixed(1);
                }
                
                // Check if pure imaginary
                if (Math.abs(re) < epsilon) {
                    if (Math.abs(imPi - Math.round(imPi)) < 0.1) {
                        const val = Math.round(imPi);
                        if (val === 1) return 'πi';
                        if (val === -1) return '-πi';
                        return val + 'πi';
                    }
                    return im.toFixed(1) + 'i';
                }
                
                // Complex number
                let result = Math.abs(re) < epsilon ? '' : re.toFixed(1);
                if (im > epsilon) {
                    result += (result ? '+' : '') + (Math.abs(im - 1) < epsilon ? '' : im.toFixed(1)) + 'i';
                } else if (im < -epsilon) {
                    result += (Math.abs(im + 1) < epsilon ? '-' : im.toFixed(1)) + 'i';
                }
                return result || '0';
            }
            
            // Regular notation (no π)
            if (Math.abs(im) < epsilon) {
                return Math.abs(re) < epsilon ? '0' : re.toFixed(0);
            }
            if (Math.abs(re) < epsilon) {
                const imVal = Math.round(im);
                if (imVal === 1) return 'i';
                if (imVal === -1) return '-i';
                return imVal + 'i';
            }
            
            const reStr = Math.round(re).toString();
            const imVal = Math.round(im);
            let imStr;
            if (imVal === 1) {
                imStr = '+i';
            } else if (imVal === -1) {
                imStr = '-i';
            } else if (imVal > 0) {
                imStr = '+' + imVal + 'i';
            } else {
                imStr = imVal + 'i';
            }
            
            return reStr + imStr;
        }
        
        // Get function name for display
        function getFuncName() {
            const names = {
                'z2': 'z²',
                'z3': 'z³',
                'exp': 'e^z',
                'sin': 'sin(z)',
                'cos': 'cos(z)'
            };
            return names[state.func] || 'f(z)';
        }
        
        for (let i = 0; i <= resolution; i++) {
            const t = (i / resolution) * 2 - 1;
            const realPart = t * range; // Real part from -range to +range
            
            let x, y; // x and y for the complex number z = x + iy
            
            if (state.fixedAxisType === 'y') {
                // Im(y) fixed: z = x + i*fixedValue
                x = realPart;
                y = state.fixedValue;
            } else {
                // Im(x) fixed: z = fixedValue + i*y
                x = state.fixedValue;
                y = realPart;
            }
            
            const result = complexFunc(x, y, state.func);
            
            // Check if result is non-zero
            if (Math.abs(result.re) > 0.001 || Math.abs(result.im) > 0.001) {
                allZero = false;
            }
            
            // Clamp extreme values for e^z
            const maxVal = 100;
            const clampedRe = Math.max(-maxVal, Math.min(maxVal, result.re));
            const clampedIm = Math.max(-maxVal, Math.min(maxVal, result.im));
            
            // Position depends on which axis is fixed
            let position;
            if (state.fixedAxisType === 'y') {
                // Im(y) fixed: (Re(z), Re(f), Im(f))
                position = new THREE.Vector3(
                    x,           // X: Re(z)
                    clampedRe,   // Y: Re(f)
                    clampedIm    // Z: Im(f)
                );
            } else {
                // Im(x) fixed: (Im(z), Re(f), Re(z))
                position = new THREE.Vector3(
                    y,           // X: Im(z)
                    clampedRe,   // Y: Re(f)
                    clampedIm    // Z: Im(f)
                );
            }
            
            points.push(position);
            
            // Add formula labels only when all coordinates are round numbers
            const epsilon = 0.15;
            const xRound = Math.abs(x - Math.round(x)) < epsilon;
            const yRound = Math.abs(y - Math.round(y)) < epsilon;
            const reRound = Math.abs(clampedRe - Math.round(clampedRe)) < 0.3; // Slightly more tolerant for output
            const imRound = Math.abs(clampedIm - Math.round(clampedIm)) < 0.3;
            
            // Create unique key for this position to avoid duplicates
            const posKey = `${Math.round(x)}_${Math.round(y)}`;
            
            // Show label if input is round AND output is reasonably round AND not already labeled
            if (xRound && yRound && (reRound || imRound) && !labeledPositions.has(posKey)) {
                labeledPositions.add(posKey);
                
                const usePi = state.func === 'sin' || state.func === 'cos';
                
                // For sin/cos, convert input to π notation
                let zStr;
                if (usePi) {
                    // Divide by π to get the coefficient
                    const xPi = x / Math.PI;
                    const yPi = y / Math.PI;
                    const innerStr = formatComplex(xPi, yPi, false);
                    zStr = 'π(' + innerStr + ')';
                } else {
                    zStr = formatComplex(x, y, false);
                }
                
                const fStr = formatComplex(clampedRe, clampedIm, false);
                const funcName = getFuncName();
                
                // Add parentheses for exponents
                let displayFunc = funcName;
                if (state.func === 'z2') {
                    displayFunc = `(${zStr})²`;
                } else if (state.func === 'z3') {
                    displayFunc = `(${zStr})³`;
                } else if (state.func === 'exp') {
                    displayFunc = `e^(${zStr})`;
                } else {
                    displayFunc = funcName.replace('z', zStr);
                }
                
                // Use ≒ if value is approximate, = if exact
                const isApprox = !reRound || !imRound;
                const equalSign = isApprox ? '≒' : '=';
                
                const labelText = `${displayFunc} ${equalSign} ${fStr}`;
                
                const label = createFormulaSprite(
                    position.x, 
                    position.y, 
                    labelText
                );
                label.position.copy(position);
                label.position.y += 3; // Offset above the curve
                scene.add(label);
                formulaLabels.push(label);
            }
            
            // Color based on |f|
            const mag = Math.sqrt(clampedRe * clampedRe + clampedIm * clampedIm);
            const t_color = Math.min(mag / 20, 1);
            let color;
            if (t_color < 0.5) {
                const s = t_color * 2;
                color = new THREE.Color(s, s, 1);
            } else {
                const s = (t_color - 0.5) * 2;
                color = new THREE.Color(1, 1 - s, 1 - s);
            }
            colors.push(color);
        }
        
        // If function returns all zeros, don't draw anything
        if (allZero) {
            console.warn('Function returns all zeros - not drawing');
            return;
        }
        
        // Add tube geometry for better visibility
        const curve = new THREE.CatmullRomCurve3(points);
        curve.curveType = 'catmullrom';
        curve.tension = 0.5;
        
        const tubeGeometry = new THREE.TubeGeometry(
            curve,
            resolution * 3,
            0.15,
            16,
            false
        );
        
        // Create color attribute for tube
        const tubeColors = new Float32Array(tubeGeometry.attributes.position.count * 3);
        const tubePositions = tubeGeometry.attributes.position.array;
        
        for (let i = 0; i < tubePositions.length; i += 3) {
            const x = tubePositions[i];
            const y = tubePositions[i + 1];
            const z = tubePositions[i + 2];
            
            // Find closest point on curve to determine color
            const mag = Math.sqrt(y * y + z * z);
            const t_color = Math.min(mag / 20, 1);
            
            let color;
            if (t_color < 0.5) {
                const s = t_color * 2;
                color = new THREE.Color(s, s, 1);
            } else {
                const s = (t_color - 0.5) * 2;
                color = new THREE.Color(1, 1 - s, 1 - s);
            }
            
            tubeColors[i] = color.r;
            tubeColors[i + 1] = color.g;
            tubeColors[i + 2] = color.b;
        }
        
        tubeGeometry.setAttribute('color', new THREE.BufferAttribute(tubeColors, 3));
        
        const tubeMaterial = new THREE.MeshPhongMaterial({
            vertexColors: true,
            shininess: 60,
            specular: 0x444444
        });
        
        surface = new THREE.Mesh(tubeGeometry, tubeMaterial);
        scene.add(surface);
    }
    
    // Player controls
    const keys = {};
    const moveSpeed = 0.2;
    const runMultiplier = 1.8;
    const mouseLookSpeed = 0.003;
    const touchLookSpeed = 0.008;
    
    let pitch = 0;
    let yaw = 0;
    
    // Virtual joystick state
    const joysticks = {
        left: { active: false, x: 0, y: 0, touchId: null }
    };
    
    // Camera touch control
    let cameraTouchId = null;
    let lastTouchX = 0;
    let lastTouchY = 0;
    
    // Track where each touch started to prevent crossover
    const touchStartPositions = new Map();
    
    // Detect mobile
    state.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (state.isMobile) {
        document.getElementById('leftJoystick').classList.add('active');
    }
    
    // Joystick handlers
    let joystickBaseX = 0;
    let joystickBaseY = 0;
    
    function handleJoystickStart(e, side) {
        e.preventDefault();
        e.stopPropagation();
        
        // Don't allow joystick to start if camera touch is already active
        if (cameraTouchId !== null) {
            return;
        }
        
        const touch = e.touches[0];
        const joystick = joysticks.left;
        
        joystick.active = true;
        joystick.touchId = touch.identifier;
        
        // Mark this touch as belonging to joystick
        touchStartPositions.set(touch.identifier, 'joystick');
        
        // Store initial joystick base position
        const element = document.getElementById(side + 'Joystick');
        const rect = element.getBoundingClientRect();
        joystickBaseX = rect.left + rect.width / 2;
        joystickBaseY = rect.top + rect.height / 2;
        
        updateJoystick(touch, side);
    }
    
    function handleJoystickEnd(e, side) {
        e.stopPropagation();
        const joystick = joysticks.left;
        
        // Check if the released touch is the joystick touch
        for (let touch of e.changedTouches) {
            if (touch.identifier === joystick.touchId) {
                joystick.active = false;
                joystick.x = 0;
                joystick.y = 0;
                joystick.touchId = null;
                
                // Clean up touch tracking
                touchStartPositions.delete(touch.identifier);
                
                const handle = document.querySelector(`#${side}Joystick .joystick-handle`);
                handle.style.transform = 'translate(-50%, -50%)';
                
                // Reset joystick position to original location
                const element = document.getElementById(side + 'Joystick');
                element.style.left = '30px';
                element.style.bottom = '30px';
                element.style.transform = 'none';
            }
        }
    }
    
    function updateJoystick(touch, side) {
        const element = document.getElementById(side + 'Joystick');
        const maxRadius = 60; // Maximum distance from base before joystick moves
        const followRadius = 40; // Radius within which joystick stays centered
        
        let deltaX = touch.clientX - joystickBaseX;
        let deltaY = touch.clientY - joystickBaseY;
        
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // If finger goes beyond max radius, move the joystick base
        if (distance > maxRadius) {
            const angle = Math.atan2(deltaY, deltaX);
            const moveDistance = distance - maxRadius;
            
            // Move joystick base
            const newBaseX = joystickBaseX + Math.cos(angle) * moveDistance;
            const newBaseY = joystickBaseY + Math.sin(angle) * moveDistance;
            
            // Constrain joystick to screen bounds
            const minX = 60;
            const maxX = window.innerWidth - 60;
            const minY = 60;
            const maxY = window.innerHeight - 60;
            
            joystickBaseX = Math.max(minX, Math.min(maxX, newBaseX));
            joystickBaseY = Math.max(minY, Math.min(maxY, newBaseY));
            
            // Update element position
            element.style.left = `${joystickBaseX - 60}px`;
            element.style.bottom = `${window.innerHeight - joystickBaseY - 60}px`;
            
            // Recalculate delta from new base
            deltaX = touch.clientX - joystickBaseX;
            deltaY = touch.clientY - joystickBaseY;
        }
        
        // Clamp handle position within followRadius
        const handleDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (handleDistance > followRadius) {
            const angle = Math.atan2(deltaY, deltaX);
            deltaX = Math.cos(angle) * followRadius;
            deltaY = Math.sin(angle) * followRadius;
        }
        
        const joystick = joysticks.left;
        joystick.x = deltaX / followRadius;
        joystick.y = deltaY / followRadius;
        
        const handle = element.querySelector('.joystick-handle');
        handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
    }
    
    const leftJoystickElement = document.getElementById('leftJoystick');
    
    // Capture all touches on joystick element and prevent them from going to document
    leftJoystickElement.addEventListener('touchstart', (e) => {
        e.stopImmediatePropagation();
        handleJoystickStart(e, 'left');
    }, { passive: false, capture: true });
    
    leftJoystickElement.addEventListener('touchend', (e) => {
        e.stopImmediatePropagation();
        handleJoystickEnd(e, 'left');
    }, { passive: false, capture: true });
    
    leftJoystickElement.addEventListener('touchmove', (e) => {
        e.preventDefault();
        e.stopImmediatePropagation();
        
        // Only update if joystick is active and this is specifically the joystick's touch
        if (!joysticks.left.active) return;
        
        for (let touch of e.touches) {
            if (touch.identifier === joysticks.left.touchId && 
                touchStartPositions.get(touch.identifier) === 'joystick') {
                updateJoystick(touch, 'left');
                break; // Only process the joystick touch
            }
        }
    }, { passive: false, capture: true });
    
    // Touch controls for camera (anywhere outside joystick)
    document.addEventListener('touchstart', (e) => {
        if (!state.isMobile) return;
        
        for (let touch of e.touches) {
            // Skip if this touch is already assigned to joystick
            if (touchStartPositions.get(touch.identifier) === 'joystick') {
                continue;
            }
            
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            
            // If touch is on keyboard modal, don't use for camera
            if (element && element.closest('#customKeyboardModal')) {
                continue;
            }
            
            // If touch is not on joystick, UI, or toggle button - use for camera
            if (!element || (!element.closest('#leftJoystick') && !element.closest('#ui') && element.id !== 'uiToggle')) {
                e.preventDefault(); // Prevent scrolling
                if (cameraTouchId === null) {
                    cameraTouchId = touch.identifier;
                    touchStartPositions.set(touch.identifier, 'camera');
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            }
        }
    }, { passive: false });
    
    document.addEventListener('touchmove', (e) => {
        if (!state.isMobile) return;
        
        for (let touch of e.touches) {
            // Strictly check: only process if this touch is marked as camera AND is the active camera touch
            if (touch.identifier === cameraTouchId && 
                touchStartPositions.get(touch.identifier) === 'camera') {
                e.preventDefault();
                
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;
                
                yaw -= deltaX * touchLookSpeed;
                pitch -= deltaY * touchLookSpeed;
                
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }
        }
    }, { passive: false });
    
    document.addEventListener('touchend', (e) => {
        for (let touch of e.changedTouches) {
            if (touch.identifier === cameraTouchId) {
                cameraTouchId = null;
                touchStartPositions.delete(touch.identifier);
            }
        }
    });
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        // Function switching
        if (e.key === 'q') setFunc('z2');
        if (e.key === 'e') setFunc('z3');
        if (e.key === 'r') setFunc('exp');
    });
    
    window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });
    
    // Mouse controls
    let isPointerLocked = false;
    
    const canvas = document.getElementById('canvas');
    
    canvas.addEventListener('click', () => {
        if (!state.isMobile) {
            canvas.requestPointerLock();
        }
    });
    
    // Prevent all scrolling on canvas
    canvas.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
    
    document.addEventListener('pointerlockchange', () => {
        isPointerLocked = document.pointerLockElement === canvas;
    });
    
    document.addEventListener('mousemove', (e) => {
        if (isPointerLocked) {
            yaw -= e.movementX * mouseLookSpeed;
            pitch -= e.movementY * mouseLookSpeed;
            // Remove pitch clamping for free rotation
        }
    });
    
    // UI handlers
    function setFunc(func) {
        state.func = func;
        document.getElementById('funcZ2').classList.toggle('active', func === 'z2');
        document.getElementById('funcZ3').classList.toggle('active', func === 'z3');
        document.getElementById('funcExp').classList.toggle('active', func === 'exp');
        document.getElementById('funcSin').classList.toggle('active', func === 'sin');
        document.getElementById('funcCos').classList.toggle('active', func === 'cos');
        updateFunctionDescription();
        createSurface();
    }
    
    function setFixedAxis(axisType) {
        state.fixedAxisType = axisType;
        document.getElementById('axisImX').classList.toggle('active', axisType === 'x');
        document.getElementById('axisImY').classList.toggle('active', axisType === 'y');
        
        // Update slider label and current function display
        updateFunctionDescription();
        
        drawCoordSystem();
        createSurface();
    }
    
    function updateFunctionDescription() {
        const funcNames = {
            'z2': '(a+bi)²',
            'z3': '(a+bi)³',
            'exp': 'e^(a+bi)',
            'sin': 'sin(a+bi)',
            'cos': 'cos(a+bi)',
            'custom': state.customFuncStr || 'f(a+bi)'
        };
        
        const funcName = funcNames[state.func] || 'f(a+bi)';
        const fixedVal = state.fixedValue.toFixed(2);
        
        let fixedDesc;
        if (state.fixedAxisType === 'y') {
            // Fixing imaginary part of input: b is fixed
            fixedDesc = `b=${fixedVal}固定 (Im(入力))`;
            document.getElementById('sliderLabel').textContent = `Im(入力) 固定値: ${fixedVal}`;
        } else {
            // Fixing real part of input: a is fixed
            fixedDesc = `a=${fixedVal}固定 (Re(入力))`;
            document.getElementById('sliderLabel').textContent = `Re(入力) 固定値: ${fixedVal}`;
        }
        
        // Update current function description
        document.getElementById('currentFunc').textContent = 
            `${funcName} = α+βi [${fixedDesc}]`;
    }
    
    function toggleFormulas() {
        state.showFormulas = !state.showFormulas;
        document.getElementById('toggleFormulas').textContent = `数式表示: ${state.showFormulas ? 'ON' : 'OFF'}`;
        document.getElementById('toggleFormulas').classList.toggle('active', state.showFormulas);
        
        // Toggle visibility of all formula labels
        formulaLabels.forEach(label => {
            label.visible = state.showFormulas;
        });
    }
    
    function keepCurrentGraph() {
        if (!surface) return;
        
        // Clone the current surface
        const clonedGeometry = surface.geometry.clone();
        const clonedMaterial = surface.material.clone();
        clonedMaterial.transparent = true;
        clonedMaterial.opacity = 0.6; // Make kept graphs slightly transparent
        
        const keptMesh = new THREE.Mesh(clonedGeometry, clonedMaterial);
        scene.add(keptMesh);
        
        const funcNames = {
            'z2': 'z²',
            'z3': 'z³',
            'exp': 'e^z',
            'sin': 'sin(z)',
            'cos': 'cos(z)'
        };
        
        const graphInfo = {
            mesh: keptMesh,
            func: state.func,
            fixedAxisType: state.fixedAxisType,
            fixedValue: state.fixedValue,
            name: `${funcNames[state.func]} [${state.fixedAxisType === 'y' ? 'Im' : 'Re'}=${state.fixedValue.toFixed(2)}]`
        };
        
        keptGraphs.push(graphInfo);
        updateKeptGraphsList();
    }
    
    function updateKeptGraphsList() {
        const container = document.getElementById('keptGraphs');
        container.innerHTML = '';
        
        if (keptGraphs.length === 0) {
            container.innerHTML = '<div style="font-size: 10px; opacity: 0.5;">保持中のグラフなし</div>';
            return;
        }
        
        keptGraphs.forEach((graph, index) => {
            const div = document.createElement('div');
            div.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 3px; margin: 2px 0; background: rgba(100,100,100,0.3); border-radius: 3px; font-size: 10px;';
            
            const label = document.createElement('span');
            label.textContent = graph.name;
            label.style.flex = '1';
            
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '×';
            deleteBtn.style.cssText = 'padding: 2px 6px; font-size: 12px; background: rgba(200,50,50,0.7); border: none; border-radius: 3px; cursor: pointer;';
            deleteBtn.addEventListener('click', () => removeKeptGraph(index));
            
            div.appendChild(label);
            div.appendChild(deleteBtn);
            container.appendChild(div);
        });
    }
    
    function removeKeptGraph(index) {
        const graph = keptGraphs[index];
        scene.remove(graph.mesh);
        graph.mesh.geometry.dispose();
        graph.mesh.material.dispose();
        keptGraphs.splice(index, 1);
        updateKeptGraphsList();
    }
    
    document.getElementById('funcZ2').addEventListener('click', () => setFunc('z2'));
    document.getElementById('funcZ3').addEventListener('click', () => setFunc('z3'));
    document.getElementById('funcExp').addEventListener('click', () => setFunc('exp'));
    document.getElementById('funcSin').addEventListener('click', () => setFunc('sin'));
    document.getElementById('funcCos').addEventListener('click', () => setFunc('cos'));
    
    // Open custom keyboard modal
    document.getElementById('openCustomKeyboard').addEventListener('click', () => {
        const modal = document.getElementById('customKeyboardModal');
        modal.style.display = 'block';
        setTimeout(() => {
            modal.style.transform = 'translateY(0)';
        }, 10);
    });
    
    // Close custom keyboard modal
    document.getElementById('closeKeyboard').addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const modal = document.getElementById('customKeyboardModal');
        modal.style.transform = 'translateY(100%)';
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    });
    
    // Apply custom function
    document.getElementById('applyCustom').addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const customInput = document.getElementById('customFuncDisplay').textContent.trim();
        if (customInput) {
            state.customFuncStr = customInput;
            state.func = 'custom';
            // Deactivate all preset function buttons
            document.getElementById('funcZ2').classList.remove('active');
            document.getElementById('funcZ3').classList.remove('active');
            document.getElementById('funcExp').classList.remove('active');
            document.getElementById('funcSin').classList.remove('active');
            document.getElementById('funcCos').classList.remove('active');
            updateFunctionDescription();
            createSurface();
            
            // Close the keyboard
            const modal = document.getElementById('customKeyboardModal');
            modal.style.transform = 'translateY(100%)';
            setTimeout(() => {
                modal.style.display = 'none';
            }, 300);
        }
    });
    
    // Function keyboard buttons
    document.querySelectorAll('.func-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const display = document.getElementById('customFuncDisplay');
            const func = btn.getAttribute('data-func');
            
            if (func === 'clear') {
                // Delete last character
                display.textContent = display.textContent.slice(0, -1);
            } else if (func === 'clearAll') {
                display.textContent = '';
            } else {
                display.textContent += func;
            }
        });
    });
    
    document.getElementById('axisImX').addEventListener('click', () => setFixedAxis('x'));
    document.getElementById('axisImY').addEventListener('click', () => setFixedAxis('y'));
    
    document.getElementById('toggleFormulas').addEventListener('click', toggleFormulas);
    document.getElementById('keepGraph').addEventListener('click', keepCurrentGraph);
    
    // UI collapse toggle
    let uiCollapsed = false;
    const toggleBtn = document.getElementById('uiToggle');
    const uiPanel = document.getElementById('ui');
    
    console.log('Toggle button:', toggleBtn);
    console.log('UI panel:', uiPanel);
    console.log('Button position:', toggleBtn.getBoundingClientRect());
    
    function handleToggle(e) {
        console.log('Toggle activated!', e.type);
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        uiCollapsed = !uiCollapsed;
        uiPanel.classList.toggle('collapsed', uiCollapsed);
        toggleBtn.classList.toggle('collapsed', uiCollapsed);
        toggleBtn.textContent = uiCollapsed ? '▶' : '◀';
    }
    
    // Use capture phase to intercept events before they reach other handlers
    toggleBtn.addEventListener('touchstart', handleToggle, { passive: false, capture: true });
    toggleBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
    }, { passive: false, capture: true });
    toggleBtn.addEventListener('click', handleToggle, { capture: true });
    
    // Arrow buttons for fine-tuning fixed value
    document.getElementById('decreaseFixed').addEventListener('click', () => {
        state.fixedValue = Math.max(-5, state.fixedValue - 0.1);
        document.getElementById('fixedValueSlider').value = state.fixedValue;
        updateFunctionDescription();
        createSurface();
    });
    
    document.getElementById('increaseFixed').addEventListener('click', () => {
        state.fixedValue = Math.min(5, state.fixedValue + 0.1);
        document.getElementById('fixedValueSlider').value = state.fixedValue;
        updateFunctionDescription();
        createSurface();
    });
    
    document.getElementById('fixedValueSlider').addEventListener('input', (e) => {
        state.fixedValue = parseFloat(e.target.value);
        updateFunctionDescription();
        createSurface();
    });
    
    // Update loop
    function updatePlayer() {
        // Camera-relative movement vectors
        const forward = new THREE.Vector3();
        const right = new THREE.Vector3();
        
        // Get camera's forward and right vectors
        camera.getWorldDirection(forward);
        forward.normalize();
        right.crossVectors(camera.up, forward).normalize();
        
        // Calculate speed (run if shift is held)
        const currentSpeed = keys['shift'] ? moveSpeed * runMultiplier : moveSpeed;
        
        // Keyboard movement - now uses full 3D camera direction
        if (keys['w']) camera.position.addScaledVector(forward, currentSpeed);
        if (keys['s']) camera.position.addScaledVector(forward, -currentSpeed);
        if (keys['a']) camera.position.addScaledVector(right, currentSpeed);
        if (keys['d']) camera.position.addScaledVector(right, -currentSpeed);
        if (keys[' ']) camera.position.y += currentSpeed;
        if (keys['control']) camera.position.y -= currentSpeed;
        
        // Joystick movement (mobile) - also uses full 3D direction
        if (state.isMobile && joysticks.left.active) {
            camera.position.addScaledVector(forward, -joysticks.left.y * moveSpeed * 1.5);
            camera.position.addScaledVector(right, -joysticks.left.x * moveSpeed * 1.5);
        }
        
        // Update camera rotation
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
        
        // Update info display
        const pos = camera.position;
        const fResult = complexFunc(pos.x, state.fixedValue, state.func);
        document.getElementById('info').textContent = 
            `z = ${pos.x.toFixed(2)} + ${state.fixedValue.toFixed(2)}i | ` +
            `f(z) = ${fResult.re.toFixed(2)} + ${fResult.im.toFixed(2)}i`;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        updatePlayer();
        renderer.render(scene, camera);
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Initialize
    updateFunctionDescription();
    updateKeptGraphsList();
    createSurface();
    animate();
</script>
```

</body>
</html>
