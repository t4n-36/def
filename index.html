<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>複素関数エクスプローラー</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overscroll-behavior: none;
        }

```
    html {
        overflow: hidden;
        touch-action: none;
        overscroll-behavior: none;
    }
    
    body {
        overflow: hidden;
        font-family: 'Arial', sans-serif;
        touch-action: none;
        overscroll-behavior: none;
    }
    
    #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
    }
    
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 100;
        max-width: 300px;
    }
    
    .button-group {
        margin: 10px 0;
    }
    
    button {
        background: rgba(100, 100, 255, 0.8);
        border: none;
        color: white;
        padding: 8px 12px;
        margin: 3px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        transition: background 0.2s;
    }
    
    button:hover {
        background: rgba(120, 120, 255, 1);
    }
    
    button.active {
        background: rgba(255, 100, 100, 0.9);
    }
    
    input[type="range"] {
        width: 100%;
        margin: 5px 0;
    }
    
    /* Virtual Joysticks */
    .joystick {
        position: absolute;
        width: 120px;
        height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        bottom: 30px;
        display: none;
        touch-action: none;
        z-index: 1000;
        transition: left 0.1s ease-out, bottom 0.1s ease-out;
    }
    
    .joystick.active {
        display: block;
    }
    
    #leftJoystick {
        left: 30px;
    }
    
    .joystick-handle {
        position: absolute;
        width: 50px;
        height: 50px;
        background: rgba(255, 255, 255, 0.5);
        border: 2px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        touch-action: none;
    }
    
    #info {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 12px;
        text-align: center;
    }
    
    @media (max-width: 768px) {
        #ui {
            font-size: 11px;
            padding: 10px;
            max-width: 200px;
        }
        
        button {
            padding: 6px 8px;
            font-size: 10px;
        }
    }
</style>
```

</head>
<body>
    <canvas id="canvas"></canvas>

```
<div id="ui">
    <div><strong>複素関数エクスプローラー</strong></div>
    <div class="button-group">
        <div>関数:</div>
        <button id="funcZ2" class="active">z²</button>
        <button id="funcZ3">z³</button>
        <button id="funcExp">e^z</button>
    </div>
    <div class="button-group">
        <label id="sliderLabel">Im(z) 固定値: 0.00</label>
        <input type="range" id="fixedValueSlider" min="-5" max="5" step="0.1" value="0">
    </div>
    <div style="margin-top: 10px; font-size: 11px; opacity: 0.8;">
        <div>PC: WASD移動, マウス視点</div>
        <div>Space上昇, Ctrl下降, Shift走る</div>
    </div>
</div>

<div id="leftJoystick" class="joystick">
    <div class="joystick-handle"></div>
</div>

<div id="info">
    位置: (0.00, 0.00, 0.00) | f(z) = 0.00 + 0.00i
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Game state
    const state = {
        mode: 'real', // 'real', 'imag', 'abs'
        func: 'z2', // 'z2', 'z3', 'exp'
        fixedAxis: true,
        fixedValue: 0,
        isMobile: false
    };
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    scene.fog = new THREE.Fog(0x1a1a2e, 30, 150);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 5, 10);
    
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // Add grid and axes
    function createAxesAndGrid() {
        const gridSize = 40;
        const gridDivisions = 40;
        
        // Grid on XZ plane (ground)
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // Main axes
        const axesHelper = new THREE.AxesHelper(25);
        scene.add(axesHelper);
        
        // Create thicker colored axes
        const axesMaterial = {
            x: new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }),
            y: new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 }),
            z: new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2 })
        };
        
        // X axis (red) - Re(z)
        const xGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-20, 0, 0),
            new THREE.Vector3(20, 0, 0)
        ]);
        const xAxis = new THREE.Line(xGeometry, axesMaterial.x);
        scene.add(xAxis);
        
        // Y axis (green) - Re(f) or Im(f)
        const yGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -20, 0),
            new THREE.Vector3(0, 20, 0)
        ]);
        const yAxis = new THREE.Line(yGeometry, axesMaterial.y);
        scene.add(yAxis);
        
        // Z axis (blue) - Im(z)
        const zGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, -20),
            new THREE.Vector3(0, 0, 20)
        ]);
        const zAxis = new THREE.Line(zGeometry, axesMaterial.z);
        scene.add(zAxis);
        
        // Add tick marks every 1 unit
        const tickSize = 0.3;
        const tickMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa });
        
        for (let i = -20; i <= 20; i++) {
            if (i === 0) continue; // Skip origin
            
            // X axis ticks
            const xTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(i, -tickSize, 0),
                new THREE.Vector3(i, tickSize, 0)
            ]);
            scene.add(new THREE.Line(xTickGeom, tickMaterial));
            
            // Y axis ticks
            const yTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-tickSize, i, 0),
                new THREE.Vector3(tickSize, i, 0)
            ]);
            scene.add(new THREE.Line(yTickGeom, tickMaterial));
            
            // Z axis ticks
            const zTickGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -tickSize, i),
                new THREE.Vector3(0, tickSize, i)
            ]);
            scene.add(new THREE.Line(zTickGeom, tickMaterial));
        }
        
        // Add small spheres at integer coordinates along axes for better visibility
        const sphereGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        for (let i = -20; i <= 20; i += 5) {
            if (i === 0) continue;
            
            // X axis markers
            const xSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            xSphere.position.set(i, 0, 0);
            scene.add(xSphere);
            
            // Y axis markers
            const ySphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            ySphere.position.set(0, i, 0);
            scene.add(ySphere);
            
            // Z axis markers
            const zSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            zSphere.position.set(0, 0, i);
            scene.add(zSphere);
        }
    }
    
    createAxesAndGrid();
    
    // Complex function computation
    function complexFunc(x, y, funcType) {
        const z = { re: x, im: y };
        let result = { re: 0, im: 0 };
        
        switch(funcType) {
            case 'z2':
                result.re = z.re * z.re - z.im * z.im;
                result.im = 2 * z.re * z.im;
                break;
            case 'z3':
                const r2 = z.re * z.re - z.im * z.im;
                const i2 = 2 * z.re * z.im;
                result.re = r2 * z.re - i2 * z.im;
                result.im = r2 * z.im + i2 * z.re;
                break;
            case 'exp':
                const expRe = Math.exp(z.re);
                result.re = expRe * Math.cos(z.im);
                result.im = expRe * Math.sin(z.im);
                break;
        }
        
        return result;
    }
    
    function getHeight(x, z) {
        // x = Re(z), z = Im(z) in 3D space
        const result = complexFunc(x, z, state.func);
        
        switch(state.mode) {
            case 'real':
                return result.re;
            case 'imag':
                return result.im;
            case 'abs':
                return Math.sqrt(result.re * result.re + result.im * result.im);
        }
    }
    
    // Create surface
    let surface;
    
    function createSurface() {
        if (surface) {
            scene.remove(surface);
            surface.geometry.dispose();
            surface.material.dispose();
        }
        
        // Fixed mode: Im(z) = fixedValue, draw (Re(z), Re(f), Im(f)) curve
        const resolution = state.isMobile ? 300 : 500;
        const range = 20;
        
        const points = [];
        const colors = [];
        
        for (let i = 0; i <= resolution; i++) {
            const t = (i / resolution) * 2 - 1;
            const reZ = t * range; // Re(z) from -range to +range
            const imZ = state.fixedValue; // Im(z) fixed
            
            const result = complexFunc(reZ, imZ, state.func);
            
            // Position: (Re(z), Re(f), Im(f))
            points.push(new THREE.Vector3(
                reZ,           // X: Re(z)
                result.re,     // Y: Re(f)
                result.im      // Z: Im(f)
            ));
            
            // Color based on |f|
            const mag = Math.sqrt(result.re * result.re + result.im * result.im);
            const t_color = Math.min(mag / 10, 1);
            let color;
            if (t_color < 0.5) {
                const s = t_color * 2;
                color = new THREE.Color(s, s, 1);
            } else {
                const s = (t_color - 0.5) * 2;
                color = new THREE.Color(1, 1 - s, 1 - s);
            }
            colors.push(color);
        }
        
        // Add tube geometry for better visibility
        const curve = new THREE.CatmullRomCurve3(points);
        curve.curveType = 'catmullrom';
        curve.tension = 0.5;
        
        const tubeGeometry = new THREE.TubeGeometry(
            curve,
            resolution * 2,
            0.15,
            16,
            false
        );
        
        // Create color attribute for tube
        const tubeColors = new Float32Array(tubeGeometry.attributes.position.count * 3);
        const tubePositions = tubeGeometry.attributes.position.array;
        
        for (let i = 0; i < tubePositions.length; i += 3) {
            const x = tubePositions[i];
            const y = tubePositions[i + 1];
            const z = tubePositions[i + 2];
            
            // Find closest point on curve to determine color
            const mag = Math.sqrt(y * y + z * z);
            const t_color = Math.min(mag / 10, 1);
            
            let color;
            if (t_color < 0.5) {
                const s = t_color * 2;
                color = new THREE.Color(s, s, 1);
            } else {
                const s = (t_color - 0.5) * 2;
                color = new THREE.Color(1, 1 - s, 1 - s);
            }
            
            tubeColors[i] = color.r;
            tubeColors[i + 1] = color.g;
            tubeColors[i + 2] = color.b;
        }
        
        tubeGeometry.setAttribute('color', new THREE.BufferAttribute(tubeColors, 3));
        
        const tubeMaterial = new THREE.MeshPhongMaterial({
            vertexColors: true,
            shininess: 60,
            specular: 0x444444
        });
        
        surface = new THREE.Mesh(tubeGeometry, tubeMaterial);
        scene.add(surface);
    }
    
    // Player controls
    const keys = {};
    const moveSpeed = 0.2;
    const runMultiplier = 1.8;
    const mouseLookSpeed = 0.003;
    const touchLookSpeed = 0.008;
    
    let pitch = 0;
    let yaw = 0;
    
    // Virtual joystick state
    const joysticks = {
        left: { active: false, x: 0, y: 0, touchId: null }
    };
    
    // Camera touch control
    let cameraTouchId = null;
    let lastTouchX = 0;
    let lastTouchY = 0;
    
    // Detect mobile
    state.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (state.isMobile) {
        document.getElementById('leftJoystick').classList.add('active');
    }
    
    // Joystick handlers
    let joystickBaseX = 0;
    let joystickBaseY = 0;
    
    function handleJoystickStart(e, side) {
        e.preventDefault();
        e.stopPropagation();
        const touch = e.touches[0];
        const joystick = joysticks.left;
        
        joystick.active = true;
        joystick.touchId = touch.identifier;
        
        // Store initial joystick base position
        const element = document.getElementById(side + 'Joystick');
        const rect = element.getBoundingClientRect();
        joystickBaseX = rect.left + rect.width / 2;
        joystickBaseY = rect.top + rect.height / 2;
        
        updateJoystick(touch, side);
    }
    
    function handleJoystickEnd(e, side) {
        e.stopPropagation();
        const joystick = joysticks.left;
        
        // Check if the released touch is the joystick touch
        for (let touch of e.changedTouches) {
            if (touch.identifier === joystick.touchId) {
                joystick.active = false;
                joystick.x = 0;
                joystick.y = 0;
                joystick.touchId = null;
                
                const handle = document.querySelector(`#${side}Joystick .joystick-handle`);
                handle.style.transform = 'translate(-50%, -50%)';
                
                // Reset joystick position to original location
                const element = document.getElementById(side + 'Joystick');
                element.style.left = '30px';
                element.style.bottom = '30px';
                element.style.transform = 'none';
            }
        }
    }
    
    function updateJoystick(touch, side) {
        const element = document.getElementById(side + 'Joystick');
        const maxRadius = 60; // Maximum distance from base before joystick moves
        const followRadius = 40; // Radius within which joystick stays centered
        
        let deltaX = touch.clientX - joystickBaseX;
        let deltaY = touch.clientY - joystickBaseY;
        
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // If finger goes beyond max radius, move the joystick base
        if (distance > maxRadius) {
            const angle = Math.atan2(deltaY, deltaX);
            const moveDistance = distance - maxRadius;
            
            // Move joystick base
            const newBaseX = joystickBaseX + Math.cos(angle) * moveDistance;
            const newBaseY = joystickBaseY + Math.sin(angle) * moveDistance;
            
            // Update base position
            joystickBaseX = newBaseX;
            joystickBaseY = newBaseY;
            
            // Update element position
            const rect = element.getBoundingClientRect();
            const currentLeft = parseFloat(element.style.left) || 30;
            const currentBottom = parseFloat(element.style.bottom) || 30;
            
            element.style.left = `${newBaseX - rect.width / 2}px`;
            element.style.bottom = `${window.innerHeight - newBaseY - rect.height / 2}px`;
            
            // Recalculate delta from new base
            deltaX = touch.clientX - newBaseX;
            deltaY = touch.clientY - newBaseY;
        }
        
        // Clamp handle position within followRadius
        const handleDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (handleDistance > followRadius) {
            const angle = Math.atan2(deltaY, deltaX);
            deltaX = Math.cos(angle) * followRadius;
            deltaY = Math.sin(angle) * followRadius;
        }
        
        const joystick = joysticks.left;
        joystick.x = deltaX / followRadius;
        joystick.y = deltaY / followRadius;
        
        const handle = element.querySelector('.joystick-handle');
        handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
    }
    
    const leftJoystickElement = document.getElementById('leftJoystick');
    
    // Capture all touches on joystick element and prevent them from going to document
    leftJoystickElement.addEventListener('touchstart', (e) => {
        e.stopImmediatePropagation();
        handleJoystickStart(e, 'left');
    }, { passive: false, capture: true });
    
    leftJoystickElement.addEventListener('touchend', (e) => {
        e.stopImmediatePropagation();
        handleJoystickEnd(e, 'left');
    }, { passive: false, capture: true });
    
    leftJoystickElement.addEventListener('touchmove', (e) => {
        e.preventDefault();
        e.stopImmediatePropagation();
        for (let touch of e.touches) {
            if (touch.identifier === joysticks.left.touchId) {
                updateJoystick(touch, 'left');
            }
        }
    }, { passive: false, capture: true });
    
    // Touch controls for camera (anywhere outside joystick)
    document.addEventListener('touchstart', (e) => {
        if (!state.isMobile) return;
        
        for (let touch of e.touches) {
            // Skip if this touch is already assigned to joystick
            if (touch.identifier === joysticks.left.touchId) {
                continue;
            }
            
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            
            // If touch is not on joystick or UI, use for camera
            if (!element || (!element.closest('#leftJoystick') && !element.closest('#ui'))) {
                e.preventDefault(); // Prevent scrolling
                if (cameraTouchId === null) {
                    cameraTouchId = touch.identifier;
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            }
        }
    }, { passive: false });
    
    document.addEventListener('touchmove', (e) => {
        if (!state.isMobile) return;
        
        for (let touch of e.touches) {
            // Only process camera touch, never joystick touch
            if (touch.identifier === cameraTouchId && touch.identifier !== joysticks.left.touchId) {
                e.preventDefault();
                
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;
                
                yaw -= deltaX * touchLookSpeed;
                pitch -= deltaY * touchLookSpeed;
                
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }
        }
    }, { passive: false });
    
    document.addEventListener('touchend', (e) => {
        for (let touch of e.changedTouches) {
            if (touch.identifier === cameraTouchId) {
                cameraTouchId = null;
            }
        }
    });
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        // Function switching
        if (e.key === 'q') setFunc('z2');
        if (e.key === 'e') setFunc('z3');
        if (e.key === 'r') setFunc('exp');
    });
    
    window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });
    
    // Mouse controls
    let isPointerLocked = false;
    
    const canvas = document.getElementById('canvas');
    
    canvas.addEventListener('click', () => {
        if (!state.isMobile) {
            canvas.requestPointerLock();
        }
    });
    
    // Prevent all scrolling on canvas
    canvas.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
    
    document.addEventListener('pointerlockchange', () => {
        isPointerLocked = document.pointerLockElement === canvas;
    });
    
    document.addEventListener('mousemove', (e) => {
        if (isPointerLocked) {
            yaw -= e.movementX * mouseLookSpeed;
            pitch -= e.movementY * mouseLookSpeed;
            // Remove pitch clamping for free rotation
        }
    });
    
    // UI handlers
    function setFunc(func) {
        state.func = func;
        document.getElementById('funcZ2').classList.toggle('active', func === 'z2');
        document.getElementById('funcZ3').classList.toggle('active', func === 'z3');
        document.getElementById('funcExp').classList.toggle('active', func === 'exp');
        createSurface();
    }
    
    document.getElementById('funcZ2').addEventListener('click', () => setFunc('z2'));
    document.getElementById('funcZ3').addEventListener('click', () => setFunc('z3'));
    document.getElementById('funcExp').addEventListener('click', () => setFunc('exp'));
    
    document.getElementById('fixedValueSlider').addEventListener('input', (e) => {
        state.fixedValue = parseFloat(e.target.value);
        document.getElementById('sliderLabel').textContent = `Im(z) 固定値: ${state.fixedValue.toFixed(2)}`;
        createSurface();
    });
    
    // Update loop
    function updatePlayer() {
        // Camera-relative movement vectors
        const forward = new THREE.Vector3();
        const right = new THREE.Vector3();
        
        // Get camera's forward and right vectors
        camera.getWorldDirection(forward);
        right.crossVectors(camera.up, forward).normalize();
        
        // For horizontal movement, we want to move parallel to the ground
        const forwardFlat = new THREE.Vector3(forward.x, 0, forward.z).normalize();
        const rightFlat = new THREE.Vector3(right.x, 0, right.z).normalize();
        
        // Calculate speed (run if shift is held)
        const currentSpeed = keys['shift'] ? moveSpeed * runMultiplier : moveSpeed;
        
        // Keyboard movement
        if (keys['w']) camera.position.addScaledVector(forwardFlat, currentSpeed);
        if (keys['s']) camera.position.addScaledVector(forwardFlat, -currentSpeed);
        if (keys['a']) camera.position.addScaledVector(rightFlat, currentSpeed);
        if (keys['d']) camera.position.addScaledVector(rightFlat, -currentSpeed);
        if (keys[' ']) camera.position.y += currentSpeed;
        if (keys['control']) camera.position.y -= currentSpeed;
        
        // Joystick movement (mobile)
        if (state.isMobile && joysticks.left.active) {
            camera.position.addScaledVector(forwardFlat, -joysticks.left.y * moveSpeed * 1.5);
            camera.position.addScaledVector(rightFlat, -joysticks.left.x * moveSpeed * 1.5);
        }
        
        // Update camera rotation
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
        
        // Update info display
        const pos = camera.position;
        const fResult = complexFunc(pos.x, state.fixedValue, state.func);
        document.getElementById('info').textContent = 
            `z = ${pos.x.toFixed(2)} + ${state.fixedValue.toFixed(2)}i | ` +
            `f(z) = ${fResult.re.toFixed(2)} + ${fResult.im.toFixed(2)}i`;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        updatePlayer();
        renderer.render(scene, camera);
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Initialize
    createSurface();
    animate();
</script>
```

</body>
</html>
